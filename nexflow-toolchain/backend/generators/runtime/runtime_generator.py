# Nexflow DSL Toolchain
# Author: Chandra Mohn

"""
Runtime Generator Module

Generates NexflowRuntime.java with built-in functions that are available
in L3 Transform and L4 Rules DSLs without requiring user implementation.

These functions follow the "zero developer Java coding" covenant - users
should never need to implement these standard operations.

COVENANT REFERENCE: See docs/COVENANT-Code-Generation-Principles.md
RFC REFERENCE: See docs/RFC-Method-Implementation-Strategy.md (Solution 1)

MODULARIZATION: Function generators are organized into mixins in the
functions/ subpackage for maintainability.
"""

from pathlib import Path

from backend.generators.base import (
    BaseGenerator,
    GeneratorConfig,
    GenerationResult,
)
from backend.generators.runtime.functions import (
    TimeFunctionsMixin,
    DateContextMixin,
    MathFunctionsMixin,
    StringFunctionsMixin,
)


class RuntimeGenerator(
    TimeFunctionsMixin,
    DateContextMixin,
    MathFunctionsMixin,
    StringFunctionsMixin,
    BaseGenerator,
):
    """
    Generator for NexflowRuntime.java - the L0 runtime library.

    This class is auto-generated once per project and provides:
    - Time functions: hour(), dayOfWeek(), now()
    - Math functions: abs(), min(), max(), round(), ceil(), floor()
    - String functions: upper(), lower(), trim(), concat(), length()
    - Collection functions: length(), append(), first(), last(), contains()
    - Comparison helpers: coalesce(), nvl(), between()
    """

    def __init__(self, config: GeneratorConfig):
        super().__init__(config)

    def generate(self, ast=None) -> GenerationResult:
        """
        Generate NexflowRuntime.java.

        Unlike other generators, this doesn't require an AST - it generates
        a static library of built-in functions.

        Args:
            ast: Not used (for API compatibility)

        Returns:
            GenerationResult containing the runtime library file
        """
        # Determine package and path
        runtime_package = f"{self.config.package_prefix}.runtime"
        package_path = self.get_package_path(runtime_package)

        # Generate the runtime class
        content = self._generate_runtime_class(runtime_package)

        # Add to result
        file_path = package_path / "NexflowRuntime.java"
        self.result.add_file(
            path=Path("src/main/java") / file_path,
            content=content,
            file_type="java"
        )

        return self.result

    def _generate_runtime_class(self, package: str) -> str:
        """Generate the complete NexflowRuntime.java content."""
        return f'''{self._generate_header()}
{self.generate_package_declaration(package)}
{self._generate_imports()}

/**
 * NexflowRuntime - Built-in functions for Nexflow DSL.
 *
 * This class provides standard functions that are available in L3 Transform
 * and L4 Rules DSLs without requiring user implementation.
 *
 * Usage in generated code:
 * <pre>
 * import static {package}.NexflowRuntime.*;
 *
 * // Time functions
 * int h = hour(timestamp);           // Extract hour (0-23)
 * int dow = dayOfWeek(timestamp);    // Day of week (1=Monday, 7=Sunday)
 *
 * // Math functions
 * BigDecimal abs = abs(value);       // Absolute value
 * BigDecimal min = min(a, b);        // Minimum of two values
 *
 * // String functions
 * String upper = upper(str);         // Uppercase
 * int len = length(str);             // String length
 *
 * // Voltage encryption functions
 * String enc = encrypt(ssn, "ssn");  // Format-preserving encryption
 * String dec = decrypt(enc, "ssn");  // Format-preserving decryption
 * </pre>
 *
 * AUTO-GENERATED by Nexflow Code Generator
 * DO NOT EDIT - Changes will be overwritten
 */
public final class NexflowRuntime {{

    private NexflowRuntime() {{
        // Utility class - prevent instantiation
    }}

{self._generate_time_functions()}

{self._generate_date_context_functions()}

{self._generate_math_functions()}

{self._generate_string_functions()}

{self._generate_collection_functions()}

{self._generate_comparison_functions()}

{self._generate_conversion_functions()}

{self._generate_voltage_functions()}
}}
'''

    def _generate_header(self) -> str:
        """Generate file header comment."""
        return '''/**
 * NexflowRuntime
 *
 * L0 Runtime Library - Built-in functions for Nexflow DSL
 *
 * AUTO-GENERATED by Nexflow Code Generator
 * DO NOT EDIT - Changes will be overwritten
 *
 * Generator: RuntimeGenerator
 */'''

    def _generate_imports(self) -> str:
        """Generate import statements."""
        imports = [
            "java.math.BigDecimal",
            "java.math.RoundingMode",
            "java.nio.charset.StandardCharsets",
            "java.security.MessageDigest",
            "java.security.NoSuchAlgorithmException",
            "java.time.DayOfWeek",
            "java.time.Instant",
            "java.time.LocalDate",
            "java.time.LocalDateTime",
            "java.time.ZoneOffset",
            "java.time.temporal.ChronoUnit",
            "java.util.Collection",
            "java.util.Collections",
            "java.util.Comparator",
            "java.util.HexFormat",
            "java.util.List",
            "java.util.Objects",
            "java.util.Optional",
            "java.util.function.Function",
            "java.util.function.Predicate",
            "java.util.stream.Collectors",
            # Voltage SDK imports (optional - only used when Voltage is configured)
            "com.voltage.securedata.enterprise.VoltageSDK",
            "com.voltage.securedata.enterprise.FPEEncryption",
        ]
        return self.generate_imports(imports)

    # _generate_time_functions() is provided by TimeFunctionsMixin

    # _generate_date_context_functions() is provided by DateContextMixin

    # _generate_math_functions() is provided by MathFunctionsMixin

    # _generate_string_functions() is provided by StringFunctionsMixin

    def _generate_collection_functions(self) -> str:
        """Generate collection functions."""
        return '''    // =========================================================================
    // Collection Functions - Basic
    // =========================================================================

    /**
     * Get the size of a collection.
     *
     * @param collection The collection
     * @return Size of collection, or 0 if null
     */
    public static int length(Collection<?> collection) {
        return collection == null ? 0 : collection.size();
    }

    /**
     * Get the size of an array.
     *
     * @param array The array
     * @return Size of array, or 0 if null
     */
    public static <T> int length(T[] array) {
        return array == null ? 0 : array.length;
    }

    /**
     * Append an item to a list (mutates the list).
     *
     * @param list The list to append to
     * @param item The item to append
     */
    public static <T> void append(List<T> list, T item) {
        if (list != null && item != null) {
            list.add(item);
        }
    }

    /**
     * Get the first element of a list.
     *
     * @param list The list
     * @return First element, or null if list is null or empty
     */
    public static <T> T first(List<T> list) {
        return (list == null || list.isEmpty()) ? null : list.get(0);
    }

    /**
     * Get the last element of a list.
     *
     * @param list The list
     * @return Last element, or null if list is null or empty
     */
    public static <T> T last(List<T> list) {
        return (list == null || list.isEmpty()) ? null : list.get(list.size() - 1);
    }

    /**
     * Check if a collection contains an element.
     *
     * @param collection The collection
     * @param item The item to search for
     * @return true if collection contains item, false otherwise
     */
    public static <T> boolean contains(Collection<T> collection, T item) {
        if (collection == null) return false;
        return collection.contains(item);
    }

    /**
     * Get an element at index from a list.
     *
     * @param list The list
     * @param index The index (0-based)
     * @return Element at index, or null if out of bounds or list is null
     */
    public static <T> T at(List<T> list, int index) {
        if (list == null || index < 0 || index >= list.size()) {
            return null;
        }
        return list.get(index);
    }

    // =========================================================================
    // Collection Predicate Functions
    // RFC: Collection Operations Instead of Loops in L4
    // =========================================================================

    /**
     * Returns true if any element matches the predicate.
     *
     * Usage in rules:
     *   when any(transactions, t -> t.getAmount().compareTo(threshold) > 0)
     *
     * @param items The collection to test
     * @param predicate The condition to check
     * @return true if at least one element matches, false otherwise (or if null/empty)
     */
    public static <T> boolean any(Collection<T> items, Predicate<T> predicate) {
        return items != null && items.stream().anyMatch(predicate);
    }

    /**
     * Returns true if all elements match the predicate.
     *
     * Usage in rules:
     *   when all(items, i -> i.getStatus().equals("APPROVED"))
     *
     * @param items The collection to test
     * @param predicate The condition to check
     * @return true if all elements match (or collection is empty/null), false otherwise
     */
    public static <T> boolean all(Collection<T> items, Predicate<T> predicate) {
        return items == null || items.isEmpty() || items.stream().allMatch(predicate);
    }

    /**
     * Returns true if no elements match the predicate.
     *
     * Usage in rules:
     *   when none(alerts, a -> a.getSeverity().equals("CRITICAL"))
     *
     * @param items The collection to test
     * @param predicate The condition to check
     * @return true if no elements match (or collection is null/empty), false otherwise
     */
    public static <T> boolean none(Collection<T> items, Predicate<T> predicate) {
        return items == null || items.stream().noneMatch(predicate);
    }

    // =========================================================================
    // Collection Aggregation Functions
    // RFC: Collection Operations Instead of Loops in L4
    // =========================================================================

    /**
     * Sum numeric field across collection.
     *
     * Usage in rules:
     *   total = sum(items, i -> i.getAmount())
     *
     * @param items The collection to aggregate
     * @param field Function to extract the numeric field
     * @return Sum of all non-null values, or ZERO if null/empty
     */
    public static <T> BigDecimal sum(Collection<T> items, Function<T, BigDecimal> field) {
        if (items == null) return BigDecimal.ZERO;
        return items.stream()
            .map(field)
            .filter(Objects::nonNull)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    /**
     * Sum Long field across collection.
     *
     * @param items The collection to aggregate
     * @param field Function to extract the numeric field
     * @return Sum of all non-null values, or 0 if null/empty
     */
    public static <T> long sumLong(Collection<T> items, Function<T, Long> field) {
        if (items == null) return 0L;
        return items.stream()
            .map(field)
            .filter(Objects::nonNull)
            .mapToLong(Long::longValue)
            .sum();
    }

    /**
     * Calculate average of numeric field across collection.
     *
     * @param items The collection to aggregate
     * @param field Function to extract the numeric field
     * @return Average of all non-null values, or ZERO if null/empty
     */
    public static <T> BigDecimal avg(Collection<T> items, Function<T, BigDecimal> field) {
        if (items == null || items.isEmpty()) return BigDecimal.ZERO;
        BigDecimal total = BigDecimal.ZERO;
        int count = 0;
        for (T item : items) {
            BigDecimal value = field.apply(item);
            if (value != null) {
                total = total.add(value);
                count++;
            }
        }
        return count == 0 ? BigDecimal.ZERO : total.divide(BigDecimal.valueOf(count), 10, java.math.RoundingMode.HALF_UP);
    }

    /**
     * Count elements in collection.
     *
     * @param items The collection
     * @return Count of elements, or 0 if null
     */
    public static int count(Collection<?> items) {
        return items == null ? 0 : items.size();
    }

    /**
     * Count elements matching predicate.
     *
     * Usage in rules:
     *   failures = count(items, i -> i.getStatus().equals("FAILED"))
     *
     * @param items The collection to count
     * @param predicate The condition to check
     * @return Count of matching elements, or 0 if null
     */
    public static <T> int count(Collection<T> items, Predicate<T> predicate) {
        if (items == null) return 0;
        return (int) items.stream().filter(predicate).count();
    }

    /**
     * Find maximum element by comparator.
     *
     * Usage in rules:
     *   highest = max(items, Comparator.comparing(Item::getPriority))
     *
     * @param items The collection to search
     * @param comparator The comparison function
     * @return Optional containing max element, or empty if null/empty
     */
    public static <T> Optional<T> max(Collection<T> items, Comparator<T> comparator) {
        if (items == null || items.isEmpty()) return Optional.empty();
        return items.stream().max(comparator);
    }

    /**
     * Find maximum value of a field across collection.
     *
     * Usage in rules:
     *   maxAmount = maxBy(items, i -> i.getAmount())
     *
     * @param items The collection to search
     * @param field Function to extract the comparable field
     * @return Optional containing max value, or empty if null/empty
     */
    public static <T, R extends Comparable<R>> Optional<R> maxBy(Collection<T> items, Function<T, R> field) {
        if (items == null || items.isEmpty()) return Optional.empty();
        return items.stream()
            .map(field)
            .filter(Objects::nonNull)
            .max(Comparator.naturalOrder());
    }

    /**
     * Find minimum element by comparator.
     *
     * @param items The collection to search
     * @param comparator The comparison function
     * @return Optional containing min element, or empty if null/empty
     */
    public static <T> Optional<T> min(Collection<T> items, Comparator<T> comparator) {
        if (items == null || items.isEmpty()) return Optional.empty();
        return items.stream().min(comparator);
    }

    /**
     * Find minimum value of a field across collection.
     *
     * Usage in rules:
     *   minAmount = minBy(items, i -> i.getAmount())
     *
     * @param items The collection to search
     * @param field Function to extract the comparable field
     * @return Optional containing min value, or empty if null/empty
     */
    public static <T, R extends Comparable<R>> Optional<R> minBy(Collection<T> items, Function<T, R> field) {
        if (items == null || items.isEmpty()) return Optional.empty();
        return items.stream()
            .map(field)
            .filter(Objects::nonNull)
            .min(Comparator.naturalOrder());
    }

    // =========================================================================
    // Collection Selection Functions
    // RFC: Collection Operations Instead of Loops in L4
    // =========================================================================

    /**
     * Find first element matching predicate.
     *
     * Usage in rules:
     *   critical = find(alerts, a -> a.getSeverity().equals("CRITICAL"))
     *
     * @param items The collection to search
     * @param predicate The condition to match
     * @return Optional containing first match, or empty if none found
     */
    public static <T> Optional<T> find(Collection<T> items, Predicate<T> predicate) {
        if (items == null) return Optional.empty();
        return items.stream().filter(predicate).findFirst();
    }

    /**
     * Filter collection to elements matching predicate.
     *
     * Usage in rules:
     *   highValue = filter(transactions, t -> t.getAmount().compareTo(threshold) > 0)
     *
     * @param items The collection to filter
     * @param predicate The condition to match
     * @return List of matching elements, or empty list if null
     */
    public static <T> List<T> filter(Collection<T> items, Predicate<T> predicate) {
        if (items == null) return Collections.emptyList();
        return items.stream().filter(predicate).collect(Collectors.toList());
    }

    /**
     * Get distinct values from collection.
     *
     * @param items The collection
     * @return List of distinct elements, or empty list if null
     */
    public static <T> List<T> distinct(Collection<T> items) {
        if (items == null) return Collections.emptyList();
        return items.stream().distinct().collect(Collectors.toList());
    }

    /**
     * Extract a field from each element in collection.
     *
     * Usage in rules:
     *   amounts = map(items, i -> i.getAmount())
     *
     * @param items The collection to transform
     * @param mapper Function to extract field from each element
     * @return List of extracted values, or empty list if null
     */
    public static <T, R> List<R> map(Collection<T> items, Function<T, R> mapper) {
        if (items == null) return Collections.emptyList();
        return items.stream().map(mapper).collect(Collectors.toList());
    }

    /**
     * Sort collection by a field.
     *
     * @param items The collection to sort
     * @param keyExtractor Function to extract the sort key
     * @return Sorted list, or empty list if null
     */
    public static <T, R extends Comparable<R>> List<T> sortBy(Collection<T> items, Function<T, R> keyExtractor) {
        if (items == null) return Collections.emptyList();
        return items.stream()
            .sorted(Comparator.comparing(keyExtractor, Comparator.nullsLast(Comparator.naturalOrder())))
            .collect(Collectors.toList());
    }

    /**
     * Sort collection by a field in descending order.
     *
     * @param items The collection to sort
     * @param keyExtractor Function to extract the sort key
     * @return Sorted list (descending), or empty list if null
     */
    public static <T, R extends Comparable<R>> List<T> sortByDesc(Collection<T> items, Function<T, R> keyExtractor) {
        if (items == null) return Collections.emptyList();
        return items.stream()
            .sorted(Comparator.comparing(keyExtractor, Comparator.nullsLast(Comparator.reverseOrder())))
            .collect(Collectors.toList());
    }

    /**
     * Take first N elements from collection.
     *
     * @param items The collection
     * @param n Maximum number of elements to take
     * @return List of first N elements, or empty list if null
     */
    public static <T> List<T> take(Collection<T> items, int n) {
        if (items == null || n <= 0) return Collections.emptyList();
        return items.stream().limit(n).collect(Collectors.toList());
    }

    /**
     * Skip first N elements from collection.
     *
     * @param items The collection
     * @param n Number of elements to skip
     * @return List of remaining elements, or empty list if null
     */
    public static <T> List<T> skip(Collection<T> items, int n) {
        if (items == null) return Collections.emptyList();
        return items.stream().skip(n).collect(Collectors.toList());
    }'''

    def _generate_comparison_functions(self) -> str:
        """Generate comparison and null-handling functions."""
        return '''    // =========================================================================
    // Comparison and Null-Handling Functions
    // =========================================================================

    /**
     * Return the first non-null value from the arguments.
     *
     * @param values Values to check
     * @return First non-null value, or null if all are null
     */
    @SafeVarargs
    public static <T> T coalesce(T... values) {
        if (values == null) return null;
        for (T value : values) {
            if (value != null) return value;
        }
        return null;
    }

    /**
     * Return value if not null, otherwise return defaultValue.
     * Alias for coalesce with two arguments (NVL from SQL).
     *
     * @param value The value to check
     * @param defaultValue The default if value is null
     * @return value if not null, otherwise defaultValue
     */
    public static <T> T nvl(T value, T defaultValue) {
        return value != null ? value : defaultValue;
    }

    /**
     * Check if a value is between two bounds (inclusive).
     *
     * @param value The value to check
     * @param lower The lower bound
     * @param upper The upper bound
     * @return true if lower <= value <= upper, false otherwise (including null)
     */
    public static <T extends Comparable<T>> boolean between(T value, T lower, T upper) {
        if (value == null || lower == null || upper == null) return false;
        return value.compareTo(lower) >= 0 && value.compareTo(upper) <= 0;
    }

    /**
     * Null-safe equals comparison.
     *
     * @param a First value
     * @param b Second value
     * @return true if both null or both equal, false otherwise
     */
    public static boolean equals(Object a, Object b) {
        return Objects.equals(a, b);
    }

    /**
     * Null-safe comparison.
     *
     * @param a First value
     * @param b Second value
     * @return Comparison result, nulls are considered less than non-nulls
     */
    public static <T extends Comparable<T>> int compare(T a, T b) {
        if (a == null && b == null) return 0;
        if (a == null) return -1;
        if (b == null) return 1;
        return a.compareTo(b);
    }

    /**
     * Check if a value is null.
     *
     * @param value The value to check
     * @return true if value is null, false otherwise
     */
    public static boolean isNull(Object value) {
        return value == null;
    }

    /**
     * Check if a value is not null.
     *
     * @param value The value to check
     * @return true if value is not null, false otherwise
     */
    public static boolean isNotNull(Object value) {
        return value != null;
    }'''

    def _generate_conversion_functions(self) -> str:
        """Generate type conversion functions."""
        return '''    // =========================================================================
    // Type Conversion Functions
    // =========================================================================

    /**
     * Parse a string to Long.
     *
     * @param str The string to parse
     * @return Parsed Long, or null if parsing fails or input is null
     */
    public static Long toLong(String str) {
        if (str == null || str.trim().isEmpty()) return null;
        try {
            return Long.parseLong(str.trim());
        } catch (NumberFormatException e) {
            return null;
        }
    }

    /**
     * Parse a string to BigDecimal.
     *
     * @param str The string to parse
     * @return Parsed BigDecimal, or null if parsing fails or input is null
     */
    public static BigDecimal toDecimal(String str) {
        if (str == null || str.trim().isEmpty()) return null;
        try {
            return new BigDecimal(str.trim());
        } catch (NumberFormatException e) {
            return null;
        }
    }

    /**
     * Convert Long to BigDecimal.
     *
     * @param value The Long value
     * @return BigDecimal representation, or null if input is null
     */
    public static BigDecimal toDecimal(Long value) {
        return value == null ? null : BigDecimal.valueOf(value);
    }

    /**
     * Convert BigDecimal to Long (truncating decimal part).
     *
     * @param value The BigDecimal value
     * @return Long representation (truncated), or null if input is null
     */
    public static Long toLong(BigDecimal value) {
        return value == null ? null : value.longValue();
    }

    /**
     * Convert any value to String.
     *
     * @param value The value to convert
     * @return String representation, or null if input is null
     */
    public static String toString(Object value) {
        return value == null ? null : value.toString();
    }

    /**
     * Parse a string to boolean.
     * Recognizes: "true", "yes", "1" as true (case-insensitive)
     *
     * @param str The string to parse
     * @return Parsed boolean, or false if parsing fails or input is null
     */
    public static boolean toBoolean(String str) {
        if (str == null) return false;
        String lower = str.trim().toLowerCase();
        return "true".equals(lower) || "yes".equals(lower) || "1".equals(lower);
    }'''

    def _generate_voltage_functions(self) -> str:
        """Generate Voltage Format-Preserving Encryption (FPE) functions."""
        return '''    // =========================================================================
    // Voltage Format-Preserving Encryption Functions
    // =========================================================================

    // Voltage SDK instance - initialized lazily on first use
    private static volatile VoltageSDK voltageSDK = null;
    private static final Object SDK_LOCK = new Object();

    /**
     * Initialize the Voltage SDK with default configuration.
     * The SDK is initialized lazily on first use of encrypt/decrypt.
     *
     * @throws RuntimeException if SDK initialization fails
     */
    private static VoltageSDK getVoltageSDK() {
        if (voltageSDK == null) {
            synchronized (SDK_LOCK) {
                if (voltageSDK == null) {
                    try {
                        // Initialize from environment or default config
                        String configPath = System.getenv("VOLTAGE_CONFIG_PATH");
                        if (configPath != null) {
                            voltageSDK = VoltageSDK.getInstance(configPath);
                        } else {
                            voltageSDK = VoltageSDK.getInstance();
                        }
                    } catch (Exception e) {
                        throw new RuntimeException("Failed to initialize Voltage SDK", e);
                    }
                }
            }
        }
        return voltageSDK;
    }

    /**
     * Encrypt a value using Voltage Format-Preserving Encryption (FPE).
     *
     * The profile determines the encryption format:
     * - "ssn": SSN format (last 4 digits clear)
     * - "pan": Credit card PAN (first 4, last 4 clear)
     * - "email": Email format preserving
     * - "phone": Phone number format
     * - "full": Full encryption (no clear text)
     *
     * Usage in DSL:
     *   encrypted_ssn = encrypt(input.ssn, "ssn")
     *   protected_pan = encrypt(input.pan, "pan")
     *
     * @param value The plaintext value to encrypt
     * @param profile The Voltage profile name (e.g., "ssn", "pan", "email")
     * @return Encrypted value in format-preserving form, or null if input is null
     */
    public static String encrypt(String value, String profile) {
        if (value == null) return null;
        try {
            return getVoltageSDK().protect(profile, value);
        } catch (Exception e) {
            throw new RuntimeException("Voltage encryption failed for profile: " + profile, e);
        }
    }

    /**
     * Decrypt a value encrypted with Voltage Format-Preserving Encryption.
     *
     * Usage in DSL:
     *   clear_ssn = decrypt(encrypted_ssn, "ssn")
     *   clear_pan = decrypt(protected_pan, "pan")
     *
     * @param value The encrypted value to decrypt
     * @param profile The Voltage profile name used during encryption
     * @return Decrypted plaintext value, or null if input is null
     */
    public static String decrypt(String value, String profile) {
        if (value == null) return null;
        try {
            return getVoltageSDK().access(profile, value);
        } catch (Exception e) {
            throw new RuntimeException("Voltage decryption failed for profile: " + profile, e);
        }
    }

    /**
     * Mask a value using a pattern (non-reversible).
     *
     * Pattern characters:
     * - '#' = show original character
     * - '*' = mask with asterisk
     * - Any other character = literal
     *
     * Examples:
     *   mask("1234567890", "***-***-####") => "***-***-7890"
     *   mask("john@example.com", "****@#####") => "****@example.com"
     *
     * @param value The value to mask
     * @param pattern The masking pattern
     * @return Masked value, or null if input is null
     */
    public static String mask(String value, String pattern) {
        if (value == null || pattern == null) return null;

        StringBuilder result = new StringBuilder();
        int valueIndex = 0;

        for (int i = 0; i < pattern.length(); i++) {
            char patternChar = pattern.charAt(i);

            if (patternChar == '#') {
                // Show original character
                if (valueIndex < value.length()) {
                    result.append(value.charAt(valueIndex));
                    valueIndex++;
                }
            } else if (patternChar == '*') {
                // Mask with asterisk, consume original character
                result.append('*');
                if (valueIndex < value.length()) {
                    valueIndex++;
                }
            } else {
                // Literal character from pattern
                result.append(patternChar);
            }
        }

        return result.toString();
    }

    /**
     * Hash a value using SHA-256 (one-way, irreversible).
     *
     * Useful for creating deterministic identifiers that cannot be reversed.
     *
     * Usage in DSL:
     *   hashed_id = hash(input.customer_id)
     *
     * @param value The value to hash
     * @return SHA-256 hash as hex string, or null if input is null
     */
    public static String hash(String value) {
        if (value == null) return null;
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hashBytes = digest.digest(value.getBytes(StandardCharsets.UTF_8));
            return HexFormat.of().formatHex(hashBytes);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("SHA-256 algorithm not available", e);
        }
    }

    /**
     * Hash a value with a salt for additional security.
     *
     * @param value The value to hash
     * @param salt The salt to prepend
     * @return SHA-256 hash as hex string, or null if value is null
     */
    public static String hash(String value, String salt) {
        if (value == null) return null;
        String salted = (salt != null ? salt : "") + value;
        return hash(salted);
    }'''
