# Nexflow DSL Toolchain
# Author: Chandra Mohn

"""
Runtime Generator Module

Generates NexflowRuntime.java with built-in functions that are available
in L3 Transform and L4 Rules DSLs without requiring user implementation.

These functions follow the "zero developer Java coding" covenant - users
should never need to implement these standard operations.

COVENANT REFERENCE: See docs/COVENANT-Code-Generation-Principles.md
RFC REFERENCE: See docs/RFC-Method-Implementation-Strategy.md (Solution 1)
"""

from pathlib import Path
from typing import Optional

from backend.generators.base import (
    BaseGenerator,
    GeneratorConfig,
    GenerationResult,
)


class RuntimeGenerator(BaseGenerator):
    """
    Generator for NexflowRuntime.java - the L0 runtime library.

    This class is auto-generated once per project and provides:
    - Time functions: hour(), dayOfWeek(), now()
    - Math functions: abs(), min(), max(), round(), ceil(), floor()
    - String functions: upper(), lower(), trim(), concat(), length()
    - Collection functions: length(), append(), first(), last(), contains()
    - Comparison helpers: coalesce(), nvl(), between()
    """

    def __init__(self, config: GeneratorConfig):
        super().__init__(config)

    def generate(self, ast=None) -> GenerationResult:
        """
        Generate NexflowRuntime.java.

        Unlike other generators, this doesn't require an AST - it generates
        a static library of built-in functions.

        Args:
            ast: Not used (for API compatibility)

        Returns:
            GenerationResult containing the runtime library file
        """
        # Determine package and path
        runtime_package = f"{self.config.package_prefix}.runtime"
        package_path = self.get_package_path(runtime_package)

        # Generate the runtime class
        content = self._generate_runtime_class(runtime_package)

        # Add to result
        file_path = package_path / "NexflowRuntime.java"
        self.result.add_file(
            path=Path("src/main/java") / file_path,
            content=content,
            file_type="java"
        )

        return self.result

    def _generate_runtime_class(self, package: str) -> str:
        """Generate the complete NexflowRuntime.java content."""
        return f'''{self._generate_header()}
{self.generate_package_declaration(package)}
{self._generate_imports()}

/**
 * NexflowRuntime - Built-in functions for Nexflow DSL.
 *
 * This class provides standard functions that are available in L3 Transform
 * and L4 Rules DSLs without requiring user implementation.
 *
 * Usage in generated code:
 * <pre>
 * import static {package}.NexflowRuntime.*;
 *
 * // Time functions
 * int h = hour(timestamp);           // Extract hour (0-23)
 * int dow = dayOfWeek(timestamp);    // Day of week (1=Monday, 7=Sunday)
 *
 * // Math functions
 * BigDecimal abs = abs(value);       // Absolute value
 * BigDecimal min = min(a, b);        // Minimum of two values
 *
 * // String functions
 * String upper = upper(str);         // Uppercase
 * int len = length(str);             // String length
 *
 * // Voltage encryption functions
 * String enc = encrypt(ssn, "ssn");  // Format-preserving encryption
 * String dec = decrypt(enc, "ssn");  // Format-preserving decryption
 * </pre>
 *
 * AUTO-GENERATED by Nexflow Code Generator
 * DO NOT EDIT - Changes will be overwritten
 */
public final class NexflowRuntime {{

    private NexflowRuntime() {{
        // Utility class - prevent instantiation
    }}

{self._generate_time_functions()}

{self._generate_date_context_functions()}

{self._generate_math_functions()}

{self._generate_string_functions()}

{self._generate_collection_functions()}

{self._generate_comparison_functions()}

{self._generate_conversion_functions()}

{self._generate_voltage_functions()}
}}
'''

    def _generate_header(self) -> str:
        """Generate file header comment."""
        return '''/**
 * NexflowRuntime
 *
 * L0 Runtime Library - Built-in functions for Nexflow DSL
 *
 * AUTO-GENERATED by Nexflow Code Generator
 * DO NOT EDIT - Changes will be overwritten
 *
 * Generator: RuntimeGenerator
 */'''

    def _generate_imports(self) -> str:
        """Generate import statements."""
        imports = [
            "java.math.BigDecimal",
            "java.math.RoundingMode",
            "java.nio.charset.StandardCharsets",
            "java.security.MessageDigest",
            "java.security.NoSuchAlgorithmException",
            "java.time.DayOfWeek",
            "java.time.Instant",
            "java.time.LocalDate",
            "java.time.LocalDateTime",
            "java.time.ZoneOffset",
            "java.time.temporal.ChronoUnit",
            "java.util.Collection",
            "java.util.Collections",
            "java.util.Comparator",
            "java.util.HexFormat",
            "java.util.List",
            "java.util.Objects",
            "java.util.Optional",
            "java.util.function.Function",
            "java.util.function.Predicate",
            "java.util.stream.Collectors",
            # Voltage SDK imports (optional - only used when Voltage is configured)
            "com.voltage.securedata.enterprise.VoltageSDK",
            "com.voltage.securedata.enterprise.FPEEncryption",
        ]
        return self.generate_imports(imports)

    def _generate_time_functions(self) -> str:
        """Generate time-related functions."""
        return '''    // =========================================================================
    // Time Functions
    // =========================================================================

    /**
     * Extract the hour (0-23) from a timestamp.
     *
     * @param timestamp The timestamp to extract hour from
     * @return Hour of day (0-23), or -1 if timestamp is null
     */
    public static int hour(Instant timestamp) {
        if (timestamp == null) return -1;
        return timestamp.atZone(ZoneOffset.UTC).getHour();
    }

    /**
     * Extract the hour (0-23) from a LocalDateTime.
     *
     * @param dateTime The datetime to extract hour from
     * @return Hour of day (0-23), or -1 if dateTime is null
     */
    public static int hour(LocalDateTime dateTime) {
        if (dateTime == null) return -1;
        return dateTime.getHour();
    }

    /**
     * Extract the day of week (1=Monday, 7=Sunday) from a timestamp.
     * Follows ISO-8601 standard where Monday is 1.
     *
     * @param timestamp The timestamp to extract day of week from
     * @return Day of week (1-7), or -1 if timestamp is null
     */
    public static int dayOfWeek(Instant timestamp) {
        if (timestamp == null) return -1;
        return timestamp.atZone(ZoneOffset.UTC).getDayOfWeek().getValue();
    }

    /**
     * Extract the day of week (1=Monday, 7=Sunday) from a LocalDate.
     *
     * @param date The date to extract day of week from
     * @return Day of week (1-7), or -1 if date is null
     */
    public static int dayOfWeek(LocalDate date) {
        if (date == null) return -1;
        return date.getDayOfWeek().getValue();
    }

    /**
     * Extract the day of month (1-31) from a timestamp.
     *
     * @param timestamp The timestamp to extract day from
     * @return Day of month (1-31), or -1 if timestamp is null
     */
    public static int dayOfMonth(Instant timestamp) {
        if (timestamp == null) return -1;
        return timestamp.atZone(ZoneOffset.UTC).getDayOfMonth();
    }

    /**
     * Extract the month (1-12) from a timestamp.
     *
     * @param timestamp The timestamp to extract month from
     * @return Month (1-12), or -1 if timestamp is null
     */
    public static int month(Instant timestamp) {
        if (timestamp == null) return -1;
        return timestamp.atZone(ZoneOffset.UTC).getMonthValue();
    }

    /**
     * Extract the year from a timestamp.
     *
     * @param timestamp The timestamp to extract year from
     * @return Year, or -1 if timestamp is null
     */
    public static int year(Instant timestamp) {
        if (timestamp == null) return -1;
        return timestamp.atZone(ZoneOffset.UTC).getYear();
    }

    /**
     * Get the current timestamp (UTC).
     *
     * @return Current instant in UTC
     */
    public static Instant now() {
        return Instant.now();
    }

    /**
     * Get the current date (UTC).
     *
     * @return Current date in UTC
     */
    public static LocalDate today() {
        return LocalDate.now(ZoneOffset.UTC);
    }

    /**
     * Calculate days between two dates.
     *
     * @param from Start date
     * @param to End date
     * @return Number of days between dates, or 0 if either is null
     */
    public static long daysBetween(LocalDate from, LocalDate to) {
        if (from == null || to == null) return 0;
        return ChronoUnit.DAYS.between(from, to);
    }

    /**
     * Calculate days between two timestamps.
     *
     * @param from Start timestamp
     * @param to End timestamp
     * @return Number of days between timestamps, or 0 if either is null
     */
    public static long daysBetween(Instant from, Instant to) {
        if (from == null || to == null) return 0;
        return ChronoUnit.DAYS.between(from, to);
    }

    /**
     * Add days to a date.
     *
     * @param date The base date
     * @param days Number of days to add (can be negative)
     * @return New date with days added, or null if date is null
     */
    public static LocalDate addDays(LocalDate date, long days) {
        if (date == null) return null;
        return date.plusDays(days);
    }

    /**
     * Add days to a timestamp.
     *
     * @param timestamp The base timestamp
     * @param days Number of days to add (can be negative)
     * @return New timestamp with days added, or null if timestamp is null
     */
    public static Instant addDays(Instant timestamp, long days) {
        if (timestamp == null) return null;
        return timestamp.plus(days, ChronoUnit.DAYS);
    }'''

    def _generate_date_context_functions(self) -> str:
        """Generate date context functions for process-level date access (v0.7.0+).

        These functions provide access to date context within processing flows:
        - processing_date: System time when the record is being processed
        - business_date: Business date from calendar context
        """
        return '''    // =========================================================================
    // Date Context Functions (v0.7.0+)
    // =========================================================================

    /**
     * Get the processing date - the system time when the record is being processed.
     *
     * This function captures the current system time when called, representing
     * when the record enters the processing pipeline. Unlike business_date which
     * comes from a business calendar, processing_date is always the wall-clock time.
     *
     * In DSL:
     *   processing_date auto
     *   ...
     *   posting_timestamp = processing_date()
     *
     * @param context The execution context (provides access to system clock)
     * @return Current processing timestamp as Instant
     */
    public static Instant processingDate(Object context) {
        // When context is available and has a configured clock, use that
        // Otherwise fall back to system clock
        return Instant.now();
    }

    /**
     * Get the business date from the calendar context.
     *
     * This function retrieves the business date from the process execution context.
     * The business date is determined by the business calendar configuration
     * (e.g., trading_calendar) and represents when the transaction will be
     * posted for accounting/settlement purposes.
     *
     * In DSL:
     *   business_date from trading_calendar
     *   ...
     *   settlement_date = business_date()
     *
     * @param context The execution context (provides access to business calendar)
     * @return Current business date as LocalDate
     */
    public static LocalDate businessDate(Object context) {
        // When context has a business calendar configured, use that
        // Otherwise fall back to current system date
        // TODO: Integrate with actual business calendar service
        return LocalDate.now();
    }

    /**
     * Get the business date plus/minus offset days.
     *
     * Useful for calculating settlement dates, value dates, etc.
     *
     * In DSL:
     *   t_plus_2 = business_date_offset(2)  // T+2 settlement
     *
     * @param context The execution context
     * @param offsetDays Number of business days to add (can be negative)
     * @return Business date offset by specified days
     */
    public static LocalDate businessDateOffset(Object context, int offsetDays) {
        LocalDate baseDate = businessDate(context);
        // TODO: Use business calendar to skip weekends/holidays
        return baseDate.plusDays(offsetDays);
    }'''

    def _generate_math_functions(self) -> str:
        """Generate math functions."""
        return '''    // =========================================================================
    // Math Functions
    // =========================================================================

    /**
     * Get the absolute value of a BigDecimal.
     *
     * @param value The value
     * @return Absolute value, or null if input is null
     */
    public static BigDecimal abs(BigDecimal value) {
        return value == null ? null : value.abs();
    }

    /**
     * Get the absolute value of a Long.
     *
     * @param value The value
     * @return Absolute value, or null if input is null
     */
    public static Long abs(Long value) {
        return value == null ? null : Math.abs(value);
    }

    /**
     * Get the minimum of two comparable values.
     *
     * @param a First value
     * @param b Second value
     * @return Minimum value (null values are ignored unless both are null)
     */
    public static <T extends Comparable<T>> T min(T a, T b) {
        if (a == null) return b;
        if (b == null) return a;
        return a.compareTo(b) <= 0 ? a : b;
    }

    /**
     * Get the maximum of two comparable values.
     *
     * @param a First value
     * @param b Second value
     * @return Maximum value (null values are ignored unless both are null)
     */
    public static <T extends Comparable<T>> T max(T a, T b) {
        if (a == null) return b;
        if (b == null) return a;
        return a.compareTo(b) >= 0 ? a : b;
    }

    /**
     * Round a BigDecimal to specified decimal places.
     *
     * @param value The value to round
     * @param decimalPlaces Number of decimal places
     * @return Rounded value, or null if input is null
     */
    public static BigDecimal round(BigDecimal value, int decimalPlaces) {
        if (value == null) return null;
        return value.setScale(decimalPlaces, RoundingMode.HALF_UP);
    }

    /**
     * Round a BigDecimal to integer (0 decimal places).
     *
     * @param value The value to round
     * @return Rounded value, or null if input is null
     */
    public static BigDecimal round(BigDecimal value) {
        return round(value, 0);
    }

    /**
     * Get the ceiling of a BigDecimal (round up to integer).
     *
     * @param value The value
     * @return Ceiling value, or null if input is null
     */
    public static BigDecimal ceil(BigDecimal value) {
        if (value == null) return null;
        return value.setScale(0, RoundingMode.CEILING);
    }

    /**
     * Get the floor of a BigDecimal (round down to integer).
     *
     * @param value The value
     * @return Floor value, or null if input is null
     */
    public static BigDecimal floor(BigDecimal value) {
        if (value == null) return null;
        return value.setScale(0, RoundingMode.FLOOR);
    }

    /**
     * Calculate the power of a BigDecimal.
     *
     * @param base The base value
     * @param exponent The exponent (must be non-negative integer)
     * @return base raised to exponent, or null if base is null
     */
    public static BigDecimal pow(BigDecimal base, int exponent) {
        if (base == null) return null;
        return base.pow(exponent);
    }

    /**
     * Calculate percentage of a value.
     *
     * @param value The base value
     * @param percentage The percentage (e.g., 10 for 10%)
     * @return Calculated percentage, or null if value is null
     */
    public static BigDecimal percentOf(BigDecimal value, BigDecimal percentage) {
        if (value == null || percentage == null) return null;
        return value.multiply(percentage).divide(new BigDecimal("100"), 10, RoundingMode.HALF_UP);
    }'''

    def _generate_string_functions(self) -> str:
        """Generate string functions."""
        return '''    // =========================================================================
    // String Functions
    // =========================================================================

    /**
     * Convert string to uppercase.
     *
     * @param str The input string
     * @return Uppercase string, or null if input is null
     */
    public static String upper(String str) {
        return str == null ? null : str.toUpperCase();
    }

    /**
     * Convert string to lowercase.
     *
     * @param str The input string
     * @return Lowercase string, or null if input is null
     */
    public static String lower(String str) {
        return str == null ? null : str.toLowerCase();
    }

    /**
     * Trim whitespace from both ends of a string.
     *
     * @param str The input string
     * @return Trimmed string, or null if input is null
     */
    public static String trim(String str) {
        return str == null ? null : str.trim();
    }

    /**
     * Get the length of a string.
     *
     * @param str The input string
     * @return Length of string, or 0 if null
     */
    public static int length(String str) {
        return str == null ? 0 : str.length();
    }

    /**
     * Concatenate multiple strings.
     *
     * @param parts The strings to concatenate
     * @return Concatenated string (null parts are treated as empty)
     */
    public static String concat(String... parts) {
        if (parts == null) return null;
        StringBuilder sb = new StringBuilder();
        for (String part : parts) {
            if (part != null) sb.append(part);
        }
        return sb.toString();
    }

    /**
     * Get a substring.
     *
     * @param str The input string
     * @param start Start index (0-based)
     * @param end End index (exclusive)
     * @return Substring, or null if input is null
     */
    public static String substring(String str, int start, int end) {
        if (str == null) return null;
        int actualEnd = Math.min(end, str.length());
        int actualStart = Math.max(0, Math.min(start, actualEnd));
        return str.substring(actualStart, actualEnd);
    }

    /**
     * Get a substring from start to end.
     *
     * @param str The input string
     * @param start Start index (0-based)
     * @return Substring from start to end, or null if input is null
     */
    public static String substring(String str, int start) {
        if (str == null) return null;
        int actualStart = Math.max(0, Math.min(start, str.length()));
        return str.substring(actualStart);
    }

    /**
     * Check if a string starts with a prefix.
     *
     * @param str The input string
     * @param prefix The prefix to check
     * @return true if str starts with prefix, false otherwise
     */
    public static boolean startsWith(String str, String prefix) {
        if (str == null || prefix == null) return false;
        return str.startsWith(prefix);
    }

    /**
     * Check if a string ends with a suffix.
     *
     * @param str The input string
     * @param suffix The suffix to check
     * @return true if str ends with suffix, false otherwise
     */
    public static boolean endsWith(String str, String suffix) {
        if (str == null || suffix == null) return false;
        return str.endsWith(suffix);
    }

    /**
     * Check if a string contains a substring.
     *
     * @param str The input string
     * @param substring The substring to search for
     * @return true if str contains substring, false otherwise
     */
    public static boolean contains(String str, String substring) {
        if (str == null || substring == null) return false;
        return str.contains(substring);
    }

    /**
     * Replace all occurrences of a pattern in a string.
     *
     * @param str The input string
     * @param oldValue The pattern to replace
     * @param newValue The replacement
     * @return String with replacements, or null if input is null
     */
    public static String replace(String str, String oldValue, String newValue) {
        if (str == null) return null;
        if (oldValue == null) return str;
        return str.replace(oldValue, newValue == null ? "" : newValue);
    }

    /**
     * Check if a string is null or empty.
     *
     * @param str The input string
     * @return true if str is null or empty, false otherwise
     */
    public static boolean isEmpty(String str) {
        return str == null || str.isEmpty();
    }

    /**
     * Check if a string is null, empty, or contains only whitespace.
     *
     * @param str The input string
     * @return true if str is null, empty, or blank, false otherwise
     */
    public static boolean isBlank(String str) {
        return str == null || str.trim().isEmpty();
    }'''

    def _generate_collection_functions(self) -> str:
        """Generate collection functions."""
        return '''    // =========================================================================
    // Collection Functions - Basic
    // =========================================================================

    /**
     * Get the size of a collection.
     *
     * @param collection The collection
     * @return Size of collection, or 0 if null
     */
    public static int length(Collection<?> collection) {
        return collection == null ? 0 : collection.size();
    }

    /**
     * Get the size of an array.
     *
     * @param array The array
     * @return Size of array, or 0 if null
     */
    public static <T> int length(T[] array) {
        return array == null ? 0 : array.length;
    }

    /**
     * Append an item to a list (mutates the list).
     *
     * @param list The list to append to
     * @param item The item to append
     */
    public static <T> void append(List<T> list, T item) {
        if (list != null && item != null) {
            list.add(item);
        }
    }

    /**
     * Get the first element of a list.
     *
     * @param list The list
     * @return First element, or null if list is null or empty
     */
    public static <T> T first(List<T> list) {
        return (list == null || list.isEmpty()) ? null : list.get(0);
    }

    /**
     * Get the last element of a list.
     *
     * @param list The list
     * @return Last element, or null if list is null or empty
     */
    public static <T> T last(List<T> list) {
        return (list == null || list.isEmpty()) ? null : list.get(list.size() - 1);
    }

    /**
     * Check if a collection contains an element.
     *
     * @param collection The collection
     * @param item The item to search for
     * @return true if collection contains item, false otherwise
     */
    public static <T> boolean contains(Collection<T> collection, T item) {
        if (collection == null) return false;
        return collection.contains(item);
    }

    /**
     * Get an element at index from a list.
     *
     * @param list The list
     * @param index The index (0-based)
     * @return Element at index, or null if out of bounds or list is null
     */
    public static <T> T at(List<T> list, int index) {
        if (list == null || index < 0 || index >= list.size()) {
            return null;
        }
        return list.get(index);
    }

    // =========================================================================
    // Collection Predicate Functions
    // RFC: Collection Operations Instead of Loops in L4
    // =========================================================================

    /**
     * Returns true if any element matches the predicate.
     *
     * Usage in rules:
     *   when any(transactions, t -> t.getAmount().compareTo(threshold) > 0)
     *
     * @param items The collection to test
     * @param predicate The condition to check
     * @return true if at least one element matches, false otherwise (or if null/empty)
     */
    public static <T> boolean any(Collection<T> items, Predicate<T> predicate) {
        return items != null && items.stream().anyMatch(predicate);
    }

    /**
     * Returns true if all elements match the predicate.
     *
     * Usage in rules:
     *   when all(items, i -> i.getStatus().equals("APPROVED"))
     *
     * @param items The collection to test
     * @param predicate The condition to check
     * @return true if all elements match (or collection is empty/null), false otherwise
     */
    public static <T> boolean all(Collection<T> items, Predicate<T> predicate) {
        return items == null || items.isEmpty() || items.stream().allMatch(predicate);
    }

    /**
     * Returns true if no elements match the predicate.
     *
     * Usage in rules:
     *   when none(alerts, a -> a.getSeverity().equals("CRITICAL"))
     *
     * @param items The collection to test
     * @param predicate The condition to check
     * @return true if no elements match (or collection is null/empty), false otherwise
     */
    public static <T> boolean none(Collection<T> items, Predicate<T> predicate) {
        return items == null || items.stream().noneMatch(predicate);
    }

    // =========================================================================
    // Collection Aggregation Functions
    // RFC: Collection Operations Instead of Loops in L4
    // =========================================================================

    /**
     * Sum numeric field across collection.
     *
     * Usage in rules:
     *   total = sum(items, i -> i.getAmount())
     *
     * @param items The collection to aggregate
     * @param field Function to extract the numeric field
     * @return Sum of all non-null values, or ZERO if null/empty
     */
    public static <T> BigDecimal sum(Collection<T> items, Function<T, BigDecimal> field) {
        if (items == null) return BigDecimal.ZERO;
        return items.stream()
            .map(field)
            .filter(Objects::nonNull)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    /**
     * Sum Long field across collection.
     *
     * @param items The collection to aggregate
     * @param field Function to extract the numeric field
     * @return Sum of all non-null values, or 0 if null/empty
     */
    public static <T> long sumLong(Collection<T> items, Function<T, Long> field) {
        if (items == null) return 0L;
        return items.stream()
            .map(field)
            .filter(Objects::nonNull)
            .mapToLong(Long::longValue)
            .sum();
    }

    /**
     * Calculate average of numeric field across collection.
     *
     * @param items The collection to aggregate
     * @param field Function to extract the numeric field
     * @return Average of all non-null values, or ZERO if null/empty
     */
    public static <T> BigDecimal avg(Collection<T> items, Function<T, BigDecimal> field) {
        if (items == null || items.isEmpty()) return BigDecimal.ZERO;
        BigDecimal total = BigDecimal.ZERO;
        int count = 0;
        for (T item : items) {
            BigDecimal value = field.apply(item);
            if (value != null) {
                total = total.add(value);
                count++;
            }
        }
        return count == 0 ? BigDecimal.ZERO : total.divide(BigDecimal.valueOf(count), 10, java.math.RoundingMode.HALF_UP);
    }

    /**
     * Count elements in collection.
     *
     * @param items The collection
     * @return Count of elements, or 0 if null
     */
    public static int count(Collection<?> items) {
        return items == null ? 0 : items.size();
    }

    /**
     * Count elements matching predicate.
     *
     * Usage in rules:
     *   failures = count(items, i -> i.getStatus().equals("FAILED"))
     *
     * @param items The collection to count
     * @param predicate The condition to check
     * @return Count of matching elements, or 0 if null
     */
    public static <T> int count(Collection<T> items, Predicate<T> predicate) {
        if (items == null) return 0;
        return (int) items.stream().filter(predicate).count();
    }

    /**
     * Find maximum element by comparator.
     *
     * Usage in rules:
     *   highest = max(items, Comparator.comparing(Item::getPriority))
     *
     * @param items The collection to search
     * @param comparator The comparison function
     * @return Optional containing max element, or empty if null/empty
     */
    public static <T> Optional<T> max(Collection<T> items, Comparator<T> comparator) {
        if (items == null || items.isEmpty()) return Optional.empty();
        return items.stream().max(comparator);
    }

    /**
     * Find maximum value of a field across collection.
     *
     * Usage in rules:
     *   maxAmount = maxBy(items, i -> i.getAmount())
     *
     * @param items The collection to search
     * @param field Function to extract the comparable field
     * @return Optional containing max value, or empty if null/empty
     */
    public static <T, R extends Comparable<R>> Optional<R> maxBy(Collection<T> items, Function<T, R> field) {
        if (items == null || items.isEmpty()) return Optional.empty();
        return items.stream()
            .map(field)
            .filter(Objects::nonNull)
            .max(Comparator.naturalOrder());
    }

    /**
     * Find minimum element by comparator.
     *
     * @param items The collection to search
     * @param comparator The comparison function
     * @return Optional containing min element, or empty if null/empty
     */
    public static <T> Optional<T> min(Collection<T> items, Comparator<T> comparator) {
        if (items == null || items.isEmpty()) return Optional.empty();
        return items.stream().min(comparator);
    }

    /**
     * Find minimum value of a field across collection.
     *
     * Usage in rules:
     *   minAmount = minBy(items, i -> i.getAmount())
     *
     * @param items The collection to search
     * @param field Function to extract the comparable field
     * @return Optional containing min value, or empty if null/empty
     */
    public static <T, R extends Comparable<R>> Optional<R> minBy(Collection<T> items, Function<T, R> field) {
        if (items == null || items.isEmpty()) return Optional.empty();
        return items.stream()
            .map(field)
            .filter(Objects::nonNull)
            .min(Comparator.naturalOrder());
    }

    // =========================================================================
    // Collection Selection Functions
    // RFC: Collection Operations Instead of Loops in L4
    // =========================================================================

    /**
     * Find first element matching predicate.
     *
     * Usage in rules:
     *   critical = find(alerts, a -> a.getSeverity().equals("CRITICAL"))
     *
     * @param items The collection to search
     * @param predicate The condition to match
     * @return Optional containing first match, or empty if none found
     */
    public static <T> Optional<T> find(Collection<T> items, Predicate<T> predicate) {
        if (items == null) return Optional.empty();
        return items.stream().filter(predicate).findFirst();
    }

    /**
     * Filter collection to elements matching predicate.
     *
     * Usage in rules:
     *   highValue = filter(transactions, t -> t.getAmount().compareTo(threshold) > 0)
     *
     * @param items The collection to filter
     * @param predicate The condition to match
     * @return List of matching elements, or empty list if null
     */
    public static <T> List<T> filter(Collection<T> items, Predicate<T> predicate) {
        if (items == null) return Collections.emptyList();
        return items.stream().filter(predicate).collect(Collectors.toList());
    }

    /**
     * Get distinct values from collection.
     *
     * @param items The collection
     * @return List of distinct elements, or empty list if null
     */
    public static <T> List<T> distinct(Collection<T> items) {
        if (items == null) return Collections.emptyList();
        return items.stream().distinct().collect(Collectors.toList());
    }

    /**
     * Extract a field from each element in collection.
     *
     * Usage in rules:
     *   amounts = map(items, i -> i.getAmount())
     *
     * @param items The collection to transform
     * @param mapper Function to extract field from each element
     * @return List of extracted values, or empty list if null
     */
    public static <T, R> List<R> map(Collection<T> items, Function<T, R> mapper) {
        if (items == null) return Collections.emptyList();
        return items.stream().map(mapper).collect(Collectors.toList());
    }

    /**
     * Sort collection by a field.
     *
     * @param items The collection to sort
     * @param keyExtractor Function to extract the sort key
     * @return Sorted list, or empty list if null
     */
    public static <T, R extends Comparable<R>> List<T> sortBy(Collection<T> items, Function<T, R> keyExtractor) {
        if (items == null) return Collections.emptyList();
        return items.stream()
            .sorted(Comparator.comparing(keyExtractor, Comparator.nullsLast(Comparator.naturalOrder())))
            .collect(Collectors.toList());
    }

    /**
     * Sort collection by a field in descending order.
     *
     * @param items The collection to sort
     * @param keyExtractor Function to extract the sort key
     * @return Sorted list (descending), or empty list if null
     */
    public static <T, R extends Comparable<R>> List<T> sortByDesc(Collection<T> items, Function<T, R> keyExtractor) {
        if (items == null) return Collections.emptyList();
        return items.stream()
            .sorted(Comparator.comparing(keyExtractor, Comparator.nullsLast(Comparator.reverseOrder())))
            .collect(Collectors.toList());
    }

    /**
     * Take first N elements from collection.
     *
     * @param items The collection
     * @param n Maximum number of elements to take
     * @return List of first N elements, or empty list if null
     */
    public static <T> List<T> take(Collection<T> items, int n) {
        if (items == null || n <= 0) return Collections.emptyList();
        return items.stream().limit(n).collect(Collectors.toList());
    }

    /**
     * Skip first N elements from collection.
     *
     * @param items The collection
     * @param n Number of elements to skip
     * @return List of remaining elements, or empty list if null
     */
    public static <T> List<T> skip(Collection<T> items, int n) {
        if (items == null) return Collections.emptyList();
        return items.stream().skip(n).collect(Collectors.toList());
    }'''

    def _generate_comparison_functions(self) -> str:
        """Generate comparison and null-handling functions."""
        return '''    // =========================================================================
    // Comparison and Null-Handling Functions
    // =========================================================================

    /**
     * Return the first non-null value from the arguments.
     *
     * @param values Values to check
     * @return First non-null value, or null if all are null
     */
    @SafeVarargs
    public static <T> T coalesce(T... values) {
        if (values == null) return null;
        for (T value : values) {
            if (value != null) return value;
        }
        return null;
    }

    /**
     * Return value if not null, otherwise return defaultValue.
     * Alias for coalesce with two arguments (NVL from SQL).
     *
     * @param value The value to check
     * @param defaultValue The default if value is null
     * @return value if not null, otherwise defaultValue
     */
    public static <T> T nvl(T value, T defaultValue) {
        return value != null ? value : defaultValue;
    }

    /**
     * Check if a value is between two bounds (inclusive).
     *
     * @param value The value to check
     * @param lower The lower bound
     * @param upper The upper bound
     * @return true if lower <= value <= upper, false otherwise (including null)
     */
    public static <T extends Comparable<T>> boolean between(T value, T lower, T upper) {
        if (value == null || lower == null || upper == null) return false;
        return value.compareTo(lower) >= 0 && value.compareTo(upper) <= 0;
    }

    /**
     * Null-safe equals comparison.
     *
     * @param a First value
     * @param b Second value
     * @return true if both null or both equal, false otherwise
     */
    public static boolean equals(Object a, Object b) {
        return Objects.equals(a, b);
    }

    /**
     * Null-safe comparison.
     *
     * @param a First value
     * @param b Second value
     * @return Comparison result, nulls are considered less than non-nulls
     */
    public static <T extends Comparable<T>> int compare(T a, T b) {
        if (a == null && b == null) return 0;
        if (a == null) return -1;
        if (b == null) return 1;
        return a.compareTo(b);
    }

    /**
     * Check if a value is null.
     *
     * @param value The value to check
     * @return true if value is null, false otherwise
     */
    public static boolean isNull(Object value) {
        return value == null;
    }

    /**
     * Check if a value is not null.
     *
     * @param value The value to check
     * @return true if value is not null, false otherwise
     */
    public static boolean isNotNull(Object value) {
        return value != null;
    }'''

    def _generate_conversion_functions(self) -> str:
        """Generate type conversion functions."""
        return '''    // =========================================================================
    // Type Conversion Functions
    // =========================================================================

    /**
     * Parse a string to Long.
     *
     * @param str The string to parse
     * @return Parsed Long, or null if parsing fails or input is null
     */
    public static Long toLong(String str) {
        if (str == null || str.trim().isEmpty()) return null;
        try {
            return Long.parseLong(str.trim());
        } catch (NumberFormatException e) {
            return null;
        }
    }

    /**
     * Parse a string to BigDecimal.
     *
     * @param str The string to parse
     * @return Parsed BigDecimal, or null if parsing fails or input is null
     */
    public static BigDecimal toDecimal(String str) {
        if (str == null || str.trim().isEmpty()) return null;
        try {
            return new BigDecimal(str.trim());
        } catch (NumberFormatException e) {
            return null;
        }
    }

    /**
     * Convert Long to BigDecimal.
     *
     * @param value The Long value
     * @return BigDecimal representation, or null if input is null
     */
    public static BigDecimal toDecimal(Long value) {
        return value == null ? null : BigDecimal.valueOf(value);
    }

    /**
     * Convert BigDecimal to Long (truncating decimal part).
     *
     * @param value The BigDecimal value
     * @return Long representation (truncated), or null if input is null
     */
    public static Long toLong(BigDecimal value) {
        return value == null ? null : value.longValue();
    }

    /**
     * Convert any value to String.
     *
     * @param value The value to convert
     * @return String representation, or null if input is null
     */
    public static String toString(Object value) {
        return value == null ? null : value.toString();
    }

    /**
     * Parse a string to boolean.
     * Recognizes: "true", "yes", "1" as true (case-insensitive)
     *
     * @param str The string to parse
     * @return Parsed boolean, or false if parsing fails or input is null
     */
    public static boolean toBoolean(String str) {
        if (str == null) return false;
        String lower = str.trim().toLowerCase();
        return "true".equals(lower) || "yes".equals(lower) || "1".equals(lower);
    }'''

    def _generate_voltage_functions(self) -> str:
        """Generate Voltage Format-Preserving Encryption (FPE) functions."""
        return '''    // =========================================================================
    // Voltage Format-Preserving Encryption Functions
    // =========================================================================

    // Voltage SDK instance - initialized lazily on first use
    private static volatile VoltageSDK voltageSDK = null;
    private static final Object SDK_LOCK = new Object();

    /**
     * Initialize the Voltage SDK with default configuration.
     * The SDK is initialized lazily on first use of encrypt/decrypt.
     *
     * @throws RuntimeException if SDK initialization fails
     */
    private static VoltageSDK getVoltageSDK() {
        if (voltageSDK == null) {
            synchronized (SDK_LOCK) {
                if (voltageSDK == null) {
                    try {
                        // Initialize from environment or default config
                        String configPath = System.getenv("VOLTAGE_CONFIG_PATH");
                        if (configPath != null) {
                            voltageSDK = VoltageSDK.getInstance(configPath);
                        } else {
                            voltageSDK = VoltageSDK.getInstance();
                        }
                    } catch (Exception e) {
                        throw new RuntimeException("Failed to initialize Voltage SDK", e);
                    }
                }
            }
        }
        return voltageSDK;
    }

    /**
     * Encrypt a value using Voltage Format-Preserving Encryption (FPE).
     *
     * The profile determines the encryption format:
     * - "ssn": SSN format (last 4 digits clear)
     * - "pan": Credit card PAN (first 4, last 4 clear)
     * - "email": Email format preserving
     * - "phone": Phone number format
     * - "full": Full encryption (no clear text)
     *
     * Usage in DSL:
     *   encrypted_ssn = encrypt(input.ssn, "ssn")
     *   protected_pan = encrypt(input.pan, "pan")
     *
     * @param value The plaintext value to encrypt
     * @param profile The Voltage profile name (e.g., "ssn", "pan", "email")
     * @return Encrypted value in format-preserving form, or null if input is null
     */
    public static String encrypt(String value, String profile) {
        if (value == null) return null;
        try {
            return getVoltageSDK().protect(profile, value);
        } catch (Exception e) {
            throw new RuntimeException("Voltage encryption failed for profile: " + profile, e);
        }
    }

    /**
     * Decrypt a value encrypted with Voltage Format-Preserving Encryption.
     *
     * Usage in DSL:
     *   clear_ssn = decrypt(encrypted_ssn, "ssn")
     *   clear_pan = decrypt(protected_pan, "pan")
     *
     * @param value The encrypted value to decrypt
     * @param profile The Voltage profile name used during encryption
     * @return Decrypted plaintext value, or null if input is null
     */
    public static String decrypt(String value, String profile) {
        if (value == null) return null;
        try {
            return getVoltageSDK().access(profile, value);
        } catch (Exception e) {
            throw new RuntimeException("Voltage decryption failed for profile: " + profile, e);
        }
    }

    /**
     * Mask a value using a pattern (non-reversible).
     *
     * Pattern characters:
     * - '#' = show original character
     * - '*' = mask with asterisk
     * - Any other character = literal
     *
     * Examples:
     *   mask("1234567890", "***-***-####") => "***-***-7890"
     *   mask("john@example.com", "****@#####") => "****@example.com"
     *
     * @param value The value to mask
     * @param pattern The masking pattern
     * @return Masked value, or null if input is null
     */
    public static String mask(String value, String pattern) {
        if (value == null || pattern == null) return null;

        StringBuilder result = new StringBuilder();
        int valueIndex = 0;

        for (int i = 0; i < pattern.length(); i++) {
            char patternChar = pattern.charAt(i);

            if (patternChar == '#') {
                // Show original character
                if (valueIndex < value.length()) {
                    result.append(value.charAt(valueIndex));
                    valueIndex++;
                }
            } else if (patternChar == '*') {
                // Mask with asterisk, consume original character
                result.append('*');
                if (valueIndex < value.length()) {
                    valueIndex++;
                }
            } else {
                // Literal character from pattern
                result.append(patternChar);
            }
        }

        return result.toString();
    }

    /**
     * Hash a value using SHA-256 (one-way, irreversible).
     *
     * Useful for creating deterministic identifiers that cannot be reversed.
     *
     * Usage in DSL:
     *   hashed_id = hash(input.customer_id)
     *
     * @param value The value to hash
     * @return SHA-256 hash as hex string, or null if input is null
     */
    public static String hash(String value) {
        if (value == null) return null;
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hashBytes = digest.digest(value.getBytes(StandardCharsets.UTF_8));
            return HexFormat.of().formatHex(hashBytes);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("SHA-256 algorithm not available", e);
        }
    }

    /**
     * Hash a value with a salt for additional security.
     *
     * @param value The value to hash
     * @param salt The salt to prepend
     * @return SHA-256 hash as hex string, or null if value is null
     */
    public static String hash(String value, String salt) {
        if (value == null) return null;
        String salted = (salt != null ? salt : "") + value;
        return hash(salted);
    }'''
