# Nexflow DSL Toolchain
# Author: Chandra Mohn

"""
Java Templates Module

Reusable Java code generation templates and patterns.
"""

from typing import List


def generate_java_header(class_name: str, description: str = "", generator: str = "") -> str:
    """Generate standard Java file header.

    Args:
        class_name: Name of the class
        description: Optional description
        generator: Optional generator name

    Returns:
        Java header comment block
    """
    desc = f" * {description}\n *\n" if description else ""
    gen_line = f" * Generator: {generator}\n" if generator else ""
    return f'''/**
 * {class_name}
 *
{desc} * AUTO-GENERATED by Nexflow Code Generator
 * DO NOT EDIT - Changes will be overwritten
 *
{gen_line} */'''


def generate_package_declaration(package: str) -> str:
    """Generate Java package declaration.

    Args:
        package: Package name

    Returns:
        Package statement
    """
    return f"package {package};\n"


def generate_imports(imports: List[str]) -> str:
    """Generate sorted, deduplicated import statements.

    Groups imports by: java.*, javax.*, org.*, com.*, others

    Args:
        imports: List of import class names

    Returns:
        Formatted import block
    """
    if not imports:
        return ''

    unique_imports = sorted(set(imports))

    # Group imports
    java_imports = [i for i in unique_imports if i.startswith('java.')]
    javax_imports = [i for i in unique_imports if i.startswith('javax.')]
    org_imports = [i for i in unique_imports if i.startswith('org.')]
    com_imports = [i for i in unique_imports if i.startswith('com.')]
    other_imports = [i for i in unique_imports
                     if not any(i.startswith(p) for p in ['java.', 'javax.', 'org.', 'com.'])]

    sections = []
    for group in [java_imports, javax_imports, org_imports, com_imports, other_imports]:
        if group:
            sections.append('\n'.join(f"import {imp};" for imp in group))

    return '\n\n'.join(sections) + '\n' if sections else ''


def generate_class_header(
    class_name: str,
    extends: str = None,
    implements: List[str] = None,
    modifiers: str = "public"
) -> str:
    """Generate class declaration line.

    Args:
        class_name: Name of the class
        extends: Optional parent class
        implements: Optional list of interfaces
        modifiers: Access modifiers (default: public)

    Returns:
        Class declaration line
    """
    parts = [modifiers, "class", class_name]

    if extends:
        parts.append(f"extends {extends}")

    if implements:
        parts.append("implements " + ", ".join(implements))

    return " ".join(parts) + " {"


def indent(code: str, level: int = 1, indent_str: str = "    ") -> str:
    """Indent a block of code.

    Args:
        code: Code to indent
        level: Number of indent levels
        indent_str: String for one indent level

    Returns:
        Indented code
    """
    prefix = indent_str * level
    return '\n'.join(prefix + line if line.strip() else line
                     for line in code.split('\n'))


def generate_method_signature(
    name: str,
    return_type: str = "void",
    params: List[tuple] = None,
    modifiers: str = "public",
    throws: List[str] = None
) -> str:
    """Generate method signature.

    Args:
        name: Method name
        return_type: Return type
        params: List of (type, name) tuples
        modifiers: Access modifiers
        throws: List of exception types

    Returns:
        Method signature line
    """
    param_str = ""
    if params:
        param_str = ", ".join(f"{t} {n}" for t, n in params)

    throws_str = ""
    if throws:
        throws_str = " throws " + ", ".join(throws)

    return f"{modifiers} {return_type} {name}({param_str}){throws_str}"
