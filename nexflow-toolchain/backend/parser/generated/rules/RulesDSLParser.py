# Generated from /Users/chandramohn/workspace/nexflow/nexflow-toolchain/grammar/RulesDSL.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,90,801,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,
        2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,
        7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,52,
        2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,59,
        7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,65,
        2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,72,
        7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,78,
        2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,1,0,1,0,4,0,171,
        8,0,11,0,12,0,172,1,0,1,0,1,1,1,1,1,1,3,1,180,8,1,1,1,3,1,183,8,
        1,1,1,3,1,186,8,1,1,1,1,1,1,1,1,1,1,1,3,1,193,8,1,1,1,3,1,196,8,
        1,1,1,3,1,199,8,1,1,1,1,1,1,2,1,2,1,2,1,2,1,3,1,3,1,4,1,4,1,4,1,
        5,1,5,1,6,1,6,1,6,1,7,1,7,1,8,1,8,1,8,4,8,222,8,8,11,8,12,8,223,
        1,9,1,9,1,9,1,9,3,9,230,8,9,1,10,1,10,1,11,1,11,1,11,1,11,3,11,238,
        8,11,1,12,1,12,1,13,1,13,1,14,1,14,1,14,1,14,1,15,1,15,1,15,4,15,
        251,8,15,11,15,12,15,252,1,16,1,16,3,16,257,8,16,1,16,4,16,260,8,
        16,11,16,12,16,261,1,17,1,17,1,17,1,18,1,18,1,18,1,19,1,19,1,20,
        1,20,1,20,1,20,1,21,1,21,3,21,278,8,21,1,21,4,21,281,8,21,11,21,
        12,21,282,1,22,1,22,1,22,1,23,1,23,1,23,1,24,1,24,3,24,293,8,24,
        1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,3,25,303,8,25,1,26,1,26,
        1,27,1,27,1,27,1,27,1,27,1,27,1,27,3,27,314,8,27,1,28,1,28,1,28,
        1,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,3,28,327,8,28,1,29,1,29,
        1,29,1,29,1,29,1,29,1,29,1,29,3,29,337,8,29,1,30,1,30,1,30,1,30,
        1,30,1,30,1,30,3,30,346,8,30,1,31,1,31,1,31,1,32,1,32,1,32,1,32,
        1,33,1,33,1,33,1,33,1,33,1,33,3,33,361,8,33,1,34,1,34,1,35,1,35,
        1,36,1,36,1,36,1,36,1,36,5,36,372,8,36,10,36,12,36,375,9,36,1,36,
        1,36,1,36,1,36,3,36,381,8,36,1,36,1,36,1,36,1,36,1,36,1,36,1,36,
        1,36,1,36,1,36,3,36,393,8,36,1,37,1,37,1,37,1,37,1,37,5,37,400,8,
        37,10,37,12,37,403,9,37,3,37,405,8,37,1,37,1,37,1,38,1,38,1,38,1,
        38,3,38,413,8,38,1,39,1,39,1,39,1,39,1,40,1,40,1,40,4,40,422,8,40,
        11,40,12,40,423,1,41,1,41,1,41,1,41,1,42,1,42,1,42,1,42,1,43,1,43,
        1,44,1,44,1,44,1,45,1,45,1,45,4,45,442,8,45,11,45,12,45,443,1,46,
        1,46,3,46,448,8,46,1,47,1,47,1,47,1,47,1,47,1,47,3,47,456,8,47,1,
        48,1,48,1,48,4,48,461,8,48,11,48,12,48,462,1,49,1,49,1,49,1,49,1,
        50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,5,50,478,8,50,10,50,12,
        50,481,9,50,1,50,1,50,1,50,1,51,1,51,1,51,1,51,3,51,490,8,51,1,51,
        4,51,493,8,51,11,51,12,51,494,1,51,1,51,1,52,1,52,1,53,1,53,1,53,
        1,53,1,53,3,53,506,8,53,1,54,1,54,1,54,1,54,1,54,1,55,1,55,1,55,
        1,55,1,55,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,5,56,527,
        8,56,10,56,12,56,530,9,56,1,56,1,56,3,56,534,8,56,1,56,1,56,1,57,
        4,57,539,8,57,11,57,12,57,540,1,58,1,58,1,58,5,58,546,8,58,10,58,
        12,58,549,9,58,1,59,1,59,1,59,3,59,554,8,59,1,59,3,59,557,8,59,1,
        59,1,59,1,59,3,59,562,8,59,1,59,3,59,565,8,59,3,59,567,8,59,1,60,
        1,60,1,60,5,60,572,8,60,10,60,12,60,575,9,60,1,61,1,61,1,62,1,62,
        1,63,1,63,1,63,5,63,584,8,63,10,63,12,63,587,9,63,1,64,3,64,590,
        8,64,1,64,1,64,1,65,1,65,1,65,1,65,1,65,1,65,3,65,600,8,65,1,66,
        1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,
        1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,
        1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,
        1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,3,66,652,8,66,
        1,67,1,67,1,68,1,68,1,68,5,68,659,8,68,10,68,12,68,662,9,68,1,69,
        1,69,1,69,5,69,667,8,69,10,69,12,69,670,9,69,1,70,3,70,673,8,70,
        1,70,1,70,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,3,71,
        687,8,71,1,72,1,72,1,72,1,72,1,72,1,72,1,72,5,72,696,8,72,10,72,
        12,72,699,9,72,1,72,1,72,1,72,3,72,704,8,72,1,73,1,73,1,74,1,74,
        1,74,1,74,1,74,5,74,713,8,74,10,74,12,74,716,9,74,3,74,718,8,74,
        1,74,1,74,1,75,1,75,1,75,5,75,725,8,75,10,75,12,75,728,9,75,1,75,
        1,75,1,75,1,75,1,75,1,75,5,75,736,8,75,10,75,12,75,739,9,75,3,75,
        741,8,75,1,76,1,76,1,77,1,77,1,77,5,77,748,8,77,10,77,12,77,751,
        9,77,1,78,1,78,1,78,1,78,5,78,757,8,78,10,78,12,78,760,9,78,3,78,
        762,8,78,1,78,1,78,1,79,1,79,1,79,1,79,5,79,770,8,79,10,79,12,79,
        773,9,79,3,79,775,8,79,1,79,1,79,1,80,1,80,1,80,1,80,1,81,1,81,1,
        82,1,82,1,82,1,82,1,82,1,82,3,82,791,8,82,1,83,1,83,1,83,1,83,1,
        83,1,83,3,83,799,8,83,1,83,0,0,84,0,2,4,6,8,10,12,14,16,18,20,22,
        24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,
        68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,
        108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,
        140,142,144,146,148,150,152,154,156,158,160,162,164,166,0,13,1,0,
        9,12,1,0,83,84,3,0,41,41,48,50,86,86,1,0,41,45,5,0,6,6,39,39,41,
        41,48,50,86,86,2,0,51,52,86,86,2,0,83,84,86,86,1,0,24,25,1,0,53,
        58,1,0,59,60,1,0,61,64,2,0,83,83,86,86,6,0,6,6,39,39,41,41,48,49,
        83,83,86,86,828,0,170,1,0,0,0,2,176,1,0,0,0,4,202,1,0,0,0,6,206,
        1,0,0,0,8,208,1,0,0,0,10,211,1,0,0,0,12,213,1,0,0,0,14,216,1,0,0,
        0,16,218,1,0,0,0,18,225,1,0,0,0,20,231,1,0,0,0,22,237,1,0,0,0,24,
        239,1,0,0,0,26,241,1,0,0,0,28,243,1,0,0,0,30,247,1,0,0,0,32,254,
        1,0,0,0,34,263,1,0,0,0,36,266,1,0,0,0,38,269,1,0,0,0,40,271,1,0,
        0,0,42,275,1,0,0,0,44,284,1,0,0,0,46,287,1,0,0,0,48,292,1,0,0,0,
        50,302,1,0,0,0,52,304,1,0,0,0,54,313,1,0,0,0,56,326,1,0,0,0,58,336,
        1,0,0,0,60,345,1,0,0,0,62,347,1,0,0,0,64,350,1,0,0,0,66,360,1,0,
        0,0,68,362,1,0,0,0,70,364,1,0,0,0,72,392,1,0,0,0,74,394,1,0,0,0,
        76,412,1,0,0,0,78,414,1,0,0,0,80,418,1,0,0,0,82,425,1,0,0,0,84,429,
        1,0,0,0,86,433,1,0,0,0,88,435,1,0,0,0,90,438,1,0,0,0,92,447,1,0,
        0,0,94,455,1,0,0,0,96,457,1,0,0,0,98,464,1,0,0,0,100,468,1,0,0,0,
        102,485,1,0,0,0,104,498,1,0,0,0,106,505,1,0,0,0,108,507,1,0,0,0,
        110,512,1,0,0,0,112,517,1,0,0,0,114,538,1,0,0,0,116,542,1,0,0,0,
        118,566,1,0,0,0,120,568,1,0,0,0,122,576,1,0,0,0,124,578,1,0,0,0,
        126,580,1,0,0,0,128,589,1,0,0,0,130,599,1,0,0,0,132,651,1,0,0,0,
        134,653,1,0,0,0,136,655,1,0,0,0,138,663,1,0,0,0,140,672,1,0,0,0,
        142,686,1,0,0,0,144,703,1,0,0,0,146,705,1,0,0,0,148,707,1,0,0,0,
        150,740,1,0,0,0,152,742,1,0,0,0,154,744,1,0,0,0,156,752,1,0,0,0,
        158,765,1,0,0,0,160,778,1,0,0,0,162,782,1,0,0,0,164,790,1,0,0,0,
        166,798,1,0,0,0,168,171,3,2,1,0,169,171,3,102,51,0,170,168,1,0,0,
        0,170,169,1,0,0,0,171,172,1,0,0,0,172,170,1,0,0,0,172,173,1,0,0,
        0,173,174,1,0,0,0,174,175,5,0,0,1,175,1,1,0,0,0,176,177,5,1,0,0,
        177,179,3,6,3,0,178,180,3,8,4,0,179,178,1,0,0,0,179,180,1,0,0,0,
        180,182,1,0,0,0,181,183,3,12,6,0,182,181,1,0,0,0,182,183,1,0,0,0,
        183,185,1,0,0,0,184,186,3,4,2,0,185,184,1,0,0,0,185,186,1,0,0,0,
        186,187,1,0,0,0,187,188,3,16,8,0,188,192,3,28,14,0,189,193,3,80,
        40,0,190,193,3,84,42,0,191,193,3,88,44,0,192,189,1,0,0,0,192,190,
        1,0,0,0,192,191,1,0,0,0,192,193,1,0,0,0,193,195,1,0,0,0,194,196,
        3,90,45,0,195,194,1,0,0,0,195,196,1,0,0,0,196,198,1,0,0,0,197,199,
        3,96,48,0,198,197,1,0,0,0,198,199,1,0,0,0,199,200,1,0,0,0,200,201,
        5,3,0,0,201,3,1,0,0,0,202,203,5,50,0,0,203,204,5,67,0,0,204,205,
        5,78,0,0,205,5,1,0,0,0,206,207,5,86,0,0,207,7,1,0,0,0,208,209,5,
        8,0,0,209,210,3,10,5,0,210,9,1,0,0,0,211,212,7,0,0,0,212,11,1,0,
        0,0,213,214,5,48,0,0,214,215,3,14,7,0,215,13,1,0,0,0,216,217,7,1,
        0,0,217,15,1,0,0,0,218,219,5,4,0,0,219,221,5,67,0,0,220,222,3,18,
        9,0,221,220,1,0,0,0,222,223,1,0,0,0,223,221,1,0,0,0,223,224,1,0,
        0,0,224,17,1,0,0,0,225,226,3,20,10,0,226,227,5,67,0,0,227,229,3,
        22,11,0,228,230,3,26,13,0,229,228,1,0,0,0,229,230,1,0,0,0,230,19,
        1,0,0,0,231,232,7,2,0,0,232,21,1,0,0,0,233,238,3,24,12,0,234,238,
        5,46,0,0,235,238,5,47,0,0,236,238,5,86,0,0,237,233,1,0,0,0,237,234,
        1,0,0,0,237,235,1,0,0,0,237,236,1,0,0,0,238,23,1,0,0,0,239,240,7,
        3,0,0,240,25,1,0,0,0,241,242,5,88,0,0,242,27,1,0,0,0,243,244,5,5,
        0,0,244,245,5,67,0,0,245,246,3,30,15,0,246,29,1,0,0,0,247,248,3,
        32,16,0,248,250,3,40,20,0,249,251,3,42,21,0,250,249,1,0,0,0,251,
        252,1,0,0,0,252,250,1,0,0,0,252,253,1,0,0,0,253,31,1,0,0,0,254,256,
        5,66,0,0,255,257,3,34,17,0,256,255,1,0,0,0,256,257,1,0,0,0,257,259,
        1,0,0,0,258,260,3,36,18,0,259,258,1,0,0,0,260,261,1,0,0,0,261,259,
        1,0,0,0,261,262,1,0,0,0,262,33,1,0,0,0,263,264,5,49,0,0,264,265,
        5,66,0,0,265,35,1,0,0,0,266,267,3,38,19,0,267,268,5,66,0,0,268,37,
        1,0,0,0,269,270,7,4,0,0,270,39,1,0,0,0,271,272,5,66,0,0,272,273,
        5,76,0,0,273,274,5,66,0,0,274,41,1,0,0,0,275,277,5,66,0,0,276,278,
        3,44,22,0,277,276,1,0,0,0,277,278,1,0,0,0,278,280,1,0,0,0,279,281,
        3,46,23,0,280,279,1,0,0,0,281,282,1,0,0,0,282,280,1,0,0,0,282,283,
        1,0,0,0,283,43,1,0,0,0,284,285,5,79,0,0,285,286,5,66,0,0,286,45,
        1,0,0,0,287,288,3,48,24,0,288,289,5,66,0,0,289,47,1,0,0,0,290,293,
        3,50,25,0,291,293,3,66,33,0,292,290,1,0,0,0,292,291,1,0,0,0,293,
        49,1,0,0,0,294,303,5,61,0,0,295,303,3,52,26,0,296,303,3,54,27,0,
        297,303,3,56,28,0,298,303,3,58,29,0,299,303,3,60,30,0,300,303,3,
        62,31,0,301,303,3,64,32,0,302,294,1,0,0,0,302,295,1,0,0,0,302,296,
        1,0,0,0,302,297,1,0,0,0,302,298,1,0,0,0,302,299,1,0,0,0,302,300,
        1,0,0,0,302,301,1,0,0,0,303,51,1,0,0,0,304,305,3,164,82,0,305,53,
        1,0,0,0,306,307,3,166,83,0,307,308,5,38,0,0,308,309,3,166,83,0,309,
        314,1,0,0,0,310,311,5,81,0,0,311,312,5,38,0,0,312,314,5,81,0,0,313,
        306,1,0,0,0,313,310,1,0,0,0,314,55,1,0,0,0,315,316,5,27,0,0,316,
        317,5,70,0,0,317,318,3,154,77,0,318,319,5,71,0,0,319,327,1,0,0,0,
        320,321,5,26,0,0,321,322,5,27,0,0,322,323,5,70,0,0,323,324,3,154,
        77,0,324,325,5,71,0,0,325,327,1,0,0,0,326,315,1,0,0,0,326,320,1,
        0,0,0,327,57,1,0,0,0,328,329,5,32,0,0,329,337,3,14,7,0,330,331,5,
        35,0,0,331,337,3,14,7,0,332,333,5,34,0,0,333,337,3,14,7,0,334,335,
        5,33,0,0,335,337,3,14,7,0,336,328,1,0,0,0,336,330,1,0,0,0,336,332,
        1,0,0,0,336,334,1,0,0,0,337,59,1,0,0,0,338,339,5,28,0,0,339,346,
        5,29,0,0,340,341,5,28,0,0,341,342,5,26,0,0,342,346,5,29,0,0,343,
        346,5,30,0,0,344,346,5,31,0,0,345,338,1,0,0,0,345,340,1,0,0,0,345,
        343,1,0,0,0,345,344,1,0,0,0,346,61,1,0,0,0,347,348,3,134,67,0,348,
        349,3,136,68,0,349,63,1,0,0,0,350,351,5,70,0,0,351,352,3,126,63,
        0,352,353,5,71,0,0,353,65,1,0,0,0,354,361,5,61,0,0,355,361,3,68,
        34,0,356,361,3,70,35,0,357,361,3,72,36,0,358,361,3,74,37,0,359,361,
        3,78,39,0,360,354,1,0,0,0,360,355,1,0,0,0,360,356,1,0,0,0,360,357,
        1,0,0,0,360,358,1,0,0,0,360,359,1,0,0,0,361,67,1,0,0,0,362,363,3,
        164,82,0,363,69,1,0,0,0,364,365,3,146,73,0,365,71,1,0,0,0,366,367,
        5,36,0,0,367,368,5,70,0,0,368,373,5,86,0,0,369,370,5,68,0,0,370,
        372,3,136,68,0,371,369,1,0,0,0,372,375,1,0,0,0,373,371,1,0,0,0,373,
        374,1,0,0,0,374,380,1,0,0,0,375,373,1,0,0,0,376,377,5,68,0,0,377,
        378,5,39,0,0,378,379,5,67,0,0,379,381,3,136,68,0,380,376,1,0,0,0,
        380,381,1,0,0,0,381,382,1,0,0,0,382,393,5,71,0,0,383,384,5,36,0,
        0,384,385,5,70,0,0,385,386,5,86,0,0,386,387,5,68,0,0,387,388,5,40,
        0,0,388,389,5,67,0,0,389,390,3,136,68,0,390,391,5,71,0,0,391,393,
        1,0,0,0,392,366,1,0,0,0,392,383,1,0,0,0,393,73,1,0,0,0,394,395,5,
        86,0,0,395,404,5,70,0,0,396,401,3,76,38,0,397,398,5,68,0,0,398,400,
        3,76,38,0,399,397,1,0,0,0,400,403,1,0,0,0,401,399,1,0,0,0,401,402,
        1,0,0,0,402,405,1,0,0,0,403,401,1,0,0,0,404,396,1,0,0,0,404,405,
        1,0,0,0,405,406,1,0,0,0,406,407,5,71,0,0,407,75,1,0,0,0,408,413,
        3,136,68,0,409,410,5,86,0,0,410,411,5,67,0,0,411,413,3,136,68,0,
        412,408,1,0,0,0,412,409,1,0,0,0,413,77,1,0,0,0,414,415,5,37,0,0,
        415,416,5,38,0,0,416,417,5,86,0,0,417,79,1,0,0,0,418,419,5,6,0,0,
        419,421,5,67,0,0,420,422,3,82,41,0,421,420,1,0,0,0,422,423,1,0,0,
        0,423,421,1,0,0,0,423,424,1,0,0,0,424,81,1,0,0,0,425,426,3,20,10,
        0,426,427,5,67,0,0,427,428,3,22,11,0,428,83,1,0,0,0,429,430,5,7,
        0,0,430,431,5,67,0,0,431,432,3,86,43,0,432,85,1,0,0,0,433,434,7,
        5,0,0,434,87,1,0,0,0,435,436,3,80,40,0,436,437,3,84,42,0,437,89,
        1,0,0,0,438,439,5,22,0,0,439,441,5,67,0,0,440,442,3,92,46,0,441,
        440,1,0,0,0,442,443,1,0,0,0,443,441,1,0,0,0,443,444,1,0,0,0,444,
        91,1,0,0,0,445,448,3,110,55,0,446,448,3,94,47,0,447,445,1,0,0,0,
        447,446,1,0,0,0,448,93,1,0,0,0,449,450,5,86,0,0,450,451,5,53,0,0,
        451,456,3,136,68,0,452,453,5,86,0,0,453,454,5,53,0,0,454,456,3,100,
        50,0,455,449,1,0,0,0,455,452,1,0,0,0,456,95,1,0,0,0,457,458,5,23,
        0,0,458,460,5,67,0,0,459,461,3,98,49,0,460,459,1,0,0,0,461,462,1,
        0,0,0,462,460,1,0,0,0,462,463,1,0,0,0,463,97,1,0,0,0,464,465,5,86,
        0,0,465,466,5,53,0,0,466,467,3,136,68,0,467,99,1,0,0,0,468,469,5,
        20,0,0,469,470,3,126,63,0,470,471,5,14,0,0,471,479,3,136,68,0,472,
        473,5,20,0,0,473,474,3,126,63,0,474,475,5,14,0,0,475,476,3,136,68,
        0,476,478,1,0,0,0,477,472,1,0,0,0,478,481,1,0,0,0,479,477,1,0,0,
        0,479,480,1,0,0,0,480,482,1,0,0,0,481,479,1,0,0,0,482,483,5,21,0,
        0,483,484,3,136,68,0,484,101,1,0,0,0,485,486,5,2,0,0,486,487,3,104,
        52,0,487,489,5,67,0,0,488,490,3,12,6,0,489,488,1,0,0,0,489,490,1,
        0,0,0,490,492,1,0,0,0,491,493,3,106,53,0,492,491,1,0,0,0,493,494,
        1,0,0,0,494,492,1,0,0,0,494,495,1,0,0,0,495,496,1,0,0,0,496,497,
        5,3,0,0,497,103,1,0,0,0,498,499,7,6,0,0,499,105,1,0,0,0,500,506,
        3,112,56,0,501,506,3,108,54,0,502,506,3,110,55,0,503,506,3,116,58,
        0,504,506,3,124,62,0,505,500,1,0,0,0,505,501,1,0,0,0,505,502,1,0,
        0,0,505,503,1,0,0,0,505,504,1,0,0,0,506,107,1,0,0,0,507,508,5,18,
        0,0,508,509,5,86,0,0,509,510,5,53,0,0,510,511,3,136,68,0,511,109,
        1,0,0,0,512,513,5,19,0,0,513,514,5,86,0,0,514,515,5,53,0,0,515,516,
        3,136,68,0,516,111,1,0,0,0,517,518,5,13,0,0,518,519,3,126,63,0,519,
        520,5,14,0,0,520,528,3,114,57,0,521,522,5,15,0,0,522,523,3,126,63,
        0,523,524,5,14,0,0,524,525,3,114,57,0,525,527,1,0,0,0,526,521,1,
        0,0,0,527,530,1,0,0,0,528,526,1,0,0,0,528,529,1,0,0,0,529,533,1,
        0,0,0,530,528,1,0,0,0,531,532,5,16,0,0,532,534,3,114,57,0,533,531,
        1,0,0,0,533,534,1,0,0,0,534,535,1,0,0,0,535,536,5,17,0,0,536,113,
        1,0,0,0,537,539,3,106,53,0,538,537,1,0,0,0,539,540,1,0,0,0,540,538,
        1,0,0,0,540,541,1,0,0,0,541,115,1,0,0,0,542,547,3,118,59,0,543,544,
        5,68,0,0,544,546,3,118,59,0,545,543,1,0,0,0,546,549,1,0,0,0,547,
        545,1,0,0,0,547,548,1,0,0,0,548,117,1,0,0,0,549,547,1,0,0,0,550,
        556,5,86,0,0,551,553,5,70,0,0,552,554,3,120,60,0,553,552,1,0,0,0,
        553,554,1,0,0,0,554,555,1,0,0,0,555,557,5,71,0,0,556,551,1,0,0,0,
        556,557,1,0,0,0,557,567,1,0,0,0,558,564,5,83,0,0,559,561,5,70,0,
        0,560,562,3,120,60,0,561,560,1,0,0,0,561,562,1,0,0,0,562,563,1,0,
        0,0,563,565,5,71,0,0,564,559,1,0,0,0,564,565,1,0,0,0,565,567,1,0,
        0,0,566,550,1,0,0,0,566,558,1,0,0,0,567,119,1,0,0,0,568,573,3,122,
        61,0,569,570,5,68,0,0,570,572,3,122,61,0,571,569,1,0,0,0,572,575,
        1,0,0,0,573,571,1,0,0,0,573,574,1,0,0,0,574,121,1,0,0,0,575,573,
        1,0,0,0,576,577,3,136,68,0,577,123,1,0,0,0,578,579,5,6,0,0,579,125,
        1,0,0,0,580,585,3,128,64,0,581,582,7,7,0,0,582,584,3,128,64,0,583,
        581,1,0,0,0,584,587,1,0,0,0,585,583,1,0,0,0,585,586,1,0,0,0,586,
        127,1,0,0,0,587,585,1,0,0,0,588,590,5,26,0,0,589,588,1,0,0,0,589,
        590,1,0,0,0,590,591,1,0,0,0,591,592,3,130,65,0,592,129,1,0,0,0,593,
        600,3,132,66,0,594,595,5,70,0,0,595,596,3,126,63,0,596,597,5,71,
        0,0,597,600,1,0,0,0,598,600,3,148,74,0,599,593,1,0,0,0,599,594,1,
        0,0,0,599,598,1,0,0,0,600,131,1,0,0,0,601,602,3,136,68,0,602,603,
        3,134,67,0,603,604,3,136,68,0,604,652,1,0,0,0,605,606,3,136,68,0,
        606,607,5,27,0,0,607,608,5,70,0,0,608,609,3,154,77,0,609,610,5,71,
        0,0,610,652,1,0,0,0,611,612,3,136,68,0,612,613,5,26,0,0,613,614,
        5,27,0,0,614,615,5,70,0,0,615,616,3,154,77,0,616,617,5,71,0,0,617,
        652,1,0,0,0,618,619,3,136,68,0,619,620,5,27,0,0,620,621,3,156,78,
        0,621,652,1,0,0,0,622,623,3,136,68,0,623,624,5,26,0,0,624,625,5,
        27,0,0,625,626,3,156,78,0,626,652,1,0,0,0,627,628,3,136,68,0,628,
        629,5,27,0,0,629,630,3,150,75,0,630,652,1,0,0,0,631,632,3,136,68,
        0,632,633,5,26,0,0,633,634,5,27,0,0,634,635,3,150,75,0,635,652,1,
        0,0,0,636,637,3,136,68,0,637,638,5,28,0,0,638,639,5,29,0,0,639,652,
        1,0,0,0,640,641,3,136,68,0,641,642,5,28,0,0,642,643,5,26,0,0,643,
        644,5,29,0,0,644,652,1,0,0,0,645,646,3,136,68,0,646,647,5,30,0,0,
        647,652,1,0,0,0,648,649,3,136,68,0,649,650,5,31,0,0,650,652,1,0,
        0,0,651,601,1,0,0,0,651,605,1,0,0,0,651,611,1,0,0,0,651,618,1,0,
        0,0,651,622,1,0,0,0,651,627,1,0,0,0,651,631,1,0,0,0,651,636,1,0,
        0,0,651,640,1,0,0,0,651,645,1,0,0,0,651,648,1,0,0,0,652,133,1,0,
        0,0,653,654,7,8,0,0,654,135,1,0,0,0,655,660,3,138,69,0,656,657,7,
        9,0,0,657,659,3,138,69,0,658,656,1,0,0,0,659,662,1,0,0,0,660,658,
        1,0,0,0,660,661,1,0,0,0,661,137,1,0,0,0,662,660,1,0,0,0,663,668,
        3,140,70,0,664,665,7,10,0,0,665,667,3,140,70,0,666,664,1,0,0,0,667,
        670,1,0,0,0,668,666,1,0,0,0,668,669,1,0,0,0,669,139,1,0,0,0,670,
        668,1,0,0,0,671,673,5,60,0,0,672,671,1,0,0,0,672,673,1,0,0,0,673,
        674,1,0,0,0,674,675,3,142,71,0,675,141,1,0,0,0,676,687,3,164,82,
        0,677,687,3,150,75,0,678,687,3,148,74,0,679,687,3,156,78,0,680,687,
        3,158,79,0,681,687,3,144,72,0,682,683,5,70,0,0,683,684,3,136,68,
        0,684,685,5,71,0,0,685,687,1,0,0,0,686,676,1,0,0,0,686,677,1,0,0,
        0,686,678,1,0,0,0,686,679,1,0,0,0,686,680,1,0,0,0,686,681,1,0,0,
        0,686,682,1,0,0,0,687,143,1,0,0,0,688,689,5,86,0,0,689,690,5,65,
        0,0,690,704,3,136,68,0,691,692,5,70,0,0,692,697,5,86,0,0,693,694,
        5,68,0,0,694,696,5,86,0,0,695,693,1,0,0,0,696,699,1,0,0,0,697,695,
        1,0,0,0,697,698,1,0,0,0,698,700,1,0,0,0,699,697,1,0,0,0,700,701,
        5,71,0,0,701,702,5,65,0,0,702,704,3,136,68,0,703,688,1,0,0,0,703,
        691,1,0,0,0,704,145,1,0,0,0,705,706,3,136,68,0,706,147,1,0,0,0,707,
        708,5,86,0,0,708,717,5,70,0,0,709,714,3,136,68,0,710,711,5,68,0,
        0,711,713,3,136,68,0,712,710,1,0,0,0,713,716,1,0,0,0,714,712,1,0,
        0,0,714,715,1,0,0,0,715,718,1,0,0,0,716,714,1,0,0,0,717,709,1,0,
        0,0,717,718,1,0,0,0,718,719,1,0,0,0,719,720,5,71,0,0,720,149,1,0,
        0,0,721,726,3,152,76,0,722,723,5,69,0,0,723,725,3,152,76,0,724,722,
        1,0,0,0,725,728,1,0,0,0,726,724,1,0,0,0,726,727,1,0,0,0,727,741,
        1,0,0,0,728,726,1,0,0,0,729,730,5,86,0,0,730,731,5,72,0,0,731,732,
        5,79,0,0,732,737,5,73,0,0,733,734,5,69,0,0,734,736,3,152,76,0,735,
        733,1,0,0,0,736,739,1,0,0,0,737,735,1,0,0,0,737,738,1,0,0,0,738,
        741,1,0,0,0,739,737,1,0,0,0,740,721,1,0,0,0,740,729,1,0,0,0,741,
        151,1,0,0,0,742,743,7,11,0,0,743,153,1,0,0,0,744,749,3,136,68,0,
        745,746,5,68,0,0,746,748,3,136,68,0,747,745,1,0,0,0,748,751,1,0,
        0,0,749,747,1,0,0,0,749,750,1,0,0,0,750,155,1,0,0,0,751,749,1,0,
        0,0,752,761,5,72,0,0,753,758,3,136,68,0,754,755,5,68,0,0,755,757,
        3,136,68,0,756,754,1,0,0,0,757,760,1,0,0,0,758,756,1,0,0,0,758,759,
        1,0,0,0,759,762,1,0,0,0,760,758,1,0,0,0,761,753,1,0,0,0,761,762,
        1,0,0,0,762,763,1,0,0,0,763,764,5,73,0,0,764,157,1,0,0,0,765,774,
        5,74,0,0,766,771,3,160,80,0,767,768,5,68,0,0,768,770,3,160,80,0,
        769,767,1,0,0,0,770,773,1,0,0,0,771,769,1,0,0,0,771,772,1,0,0,0,
        772,775,1,0,0,0,773,771,1,0,0,0,774,766,1,0,0,0,774,775,1,0,0,0,
        775,776,1,0,0,0,776,777,5,75,0,0,777,159,1,0,0,0,778,779,3,162,81,
        0,779,780,5,67,0,0,780,781,3,136,68,0,781,161,1,0,0,0,782,783,7,
        12,0,0,783,163,1,0,0,0,784,791,3,14,7,0,785,791,3,166,83,0,786,791,
        5,81,0,0,787,791,5,82,0,0,788,791,5,77,0,0,789,791,5,29,0,0,790,
        784,1,0,0,0,790,785,1,0,0,0,790,786,1,0,0,0,790,787,1,0,0,0,790,
        788,1,0,0,0,790,789,1,0,0,0,791,165,1,0,0,0,792,799,5,79,0,0,793,
        799,5,80,0,0,794,795,5,60,0,0,795,799,5,79,0,0,796,797,5,60,0,0,
        797,799,5,80,0,0,798,792,1,0,0,0,798,793,1,0,0,0,798,794,1,0,0,0,
        798,796,1,0,0,0,799,167,1,0,0,0,70,170,172,179,182,185,192,195,198,
        223,229,237,252,256,261,277,282,292,302,313,326,336,345,360,373,
        380,392,401,404,412,423,443,447,455,462,479,489,494,505,528,533,
        540,547,553,556,561,564,566,573,585,589,599,651,660,668,672,686,
        697,703,714,717,726,737,740,749,758,761,771,774,790,798
    ]

class RulesDSLParser ( Parser ):

    grammarFileName = "RulesDSL.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'decision_table'", "'rule'", "'end'", 
                     "'given'", "'decide'", "'return'", "'execute'", "'hit_policy'", 
                     "'first_match'", "'single_hit'", "'multi_hit'", "'collect_all'", 
                     "'if'", "'then'", "'elseif'", "'else'", "'endif'", 
                     "'set'", "'let'", "'when'", "'otherwise'", "'post_calculate'", 
                     "'aggregate'", "'and'", "'or'", "'not'", "'in'", "'is'", 
                     "'null'", "'is_null'", "'is_not_null'", "'matches'", 
                     "'contains'", "'starts_with'", "'ends_with'", "'lookup'", 
                     "'emit'", "'to'", "'default'", "'as_of'", "'text'", 
                     "'number'", "'boolean'", "'date'", "'timestamp'", "'money'", 
                     "'percentage'", "'description'", "'priority'", "'version'", 
                     "'yes'", "'multi'", "<INVALID>", "'!='", "'<'", "'>'", 
                     "'<='", "'>='", "'+'", "'-'", "'*'", "'/'", "'%'", 
                     "'mod'", "'->'", "'|'", "':'", "','", "'.'", "'('", 
                     "')'", "'['", "']'", "'{'", "'}'" ]

    symbolicNames = [ "<INVALID>", "DECISION_TABLE", "RULE", "END", "GIVEN", 
                      "DECIDE", "RETURN", "EXECUTE", "HIT_POLICY", "FIRST_MATCH", 
                      "SINGLE_HIT", "MULTI_HIT", "COLLECT_ALL", "IF", "THEN", 
                      "ELSEIF", "ELSE", "ENDIF", "SET", "LET", "WHEN", "OTHERWISE", 
                      "POST_CALCULATE", "AGGREGATE", "AND", "OR", "NOT", 
                      "IN", "IS", "NULL", "IS_NULL", "IS_NOT_NULL", "MATCHES", 
                      "CONTAINS", "STARTS_WITH", "ENDS_WITH", "LOOKUP", 
                      "EMIT", "TO", "DEFAULT", "AS_OF", "TEXT_TYPE", "NUMBER_TYPE", 
                      "BOOLEAN_TYPE", "DATE_TYPE", "TIMESTAMP_TYPE", "MONEY_TYPE", 
                      "PERCENTAGE_TYPE", "DESCRIPTION", "PRIORITY", "VERSION", 
                      "YES", "MULTI", "EQ", "NE", "LT", "GT", "LE", "GE", 
                      "PLUS", "MINUS", "STAR", "SLASH", "PERCENT", "MOD", 
                      "ARROW", "PIPE", "COLON", "COMMA", "DOT", "LPAREN", 
                      "RPAREN", "LBRACKET", "RBRACKET", "LBRACE", "RBRACE", 
                      "SEP", "BOOLEAN", "VERSION_NUMBER", "INTEGER", "DECIMAL", 
                      "MONEY_LITERAL", "PERCENTAGE_LITERAL", "DQUOTED_STRING", 
                      "SQUOTED_STRING", "STRING", "IDENTIFIER", "LINE_COMMENT", 
                      "LINE_COMMENT_INLINE", "BLOCK_COMMENT", "WS" ]

    RULE_program = 0
    RULE_decisionTableDef = 1
    RULE_versionDecl = 2
    RULE_tableName = 3
    RULE_hitPolicyDecl = 4
    RULE_hitPolicyType = 5
    RULE_descriptionDecl = 6
    RULE_stringLiteral = 7
    RULE_givenBlock = 8
    RULE_inputParam = 9
    RULE_paramName = 10
    RULE_paramType = 11
    RULE_baseType = 12
    RULE_inlineComment = 13
    RULE_decideBlock = 14
    RULE_tableMatrix = 15
    RULE_tableHeader = 16
    RULE_priorityHeader = 17
    RULE_columnHeader = 18
    RULE_columnName = 19
    RULE_tableSeparator = 20
    RULE_tableRow = 21
    RULE_priorityCell = 22
    RULE_cell = 23
    RULE_cellContent = 24
    RULE_condition = 25
    RULE_exactMatch = 26
    RULE_rangeCondition = 27
    RULE_setCondition = 28
    RULE_patternCondition = 29
    RULE_nullCondition = 30
    RULE_comparisonCondition = 31
    RULE_expressionCondition = 32
    RULE_action = 33
    RULE_assignAction = 34
    RULE_calculateAction = 35
    RULE_lookupAction = 36
    RULE_callAction = 37
    RULE_actionArg = 38
    RULE_emitAction = 39
    RULE_returnSpec = 40
    RULE_returnParam = 41
    RULE_executeSpec = 42
    RULE_executeType = 43
    RULE_hybridSpec = 44
    RULE_postCalculateBlock = 45
    RULE_postCalculateStatement = 46
    RULE_assignmentStatement = 47
    RULE_aggregateBlock = 48
    RULE_aggregateStatement = 49
    RULE_whenExpression = 50
    RULE_proceduralRuleDef = 51
    RULE_ruleName = 52
    RULE_blockItem = 53
    RULE_setStatement = 54
    RULE_letStatement = 55
    RULE_ruleStep = 56
    RULE_block = 57
    RULE_actionSequence = 58
    RULE_actionCall = 59
    RULE_parameterList = 60
    RULE_parameter = 61
    RULE_returnStatement = 62
    RULE_booleanExpr = 63
    RULE_booleanTerm = 64
    RULE_booleanFactor = 65
    RULE_comparisonExpr = 66
    RULE_comparisonOp = 67
    RULE_valueExpr = 68
    RULE_term = 69
    RULE_factor = 70
    RULE_atom = 71
    RULE_lambdaExpression = 72
    RULE_arithmeticExpr = 73
    RULE_functionCall = 74
    RULE_fieldPath = 75
    RULE_attributeIdentifier = 76
    RULE_valueList = 77
    RULE_listLiteral = 78
    RULE_objectLiteral = 79
    RULE_objectField = 80
    RULE_objectFieldName = 81
    RULE_literal = 82
    RULE_numberLiteral = 83

    ruleNames =  [ "program", "decisionTableDef", "versionDecl", "tableName", 
                   "hitPolicyDecl", "hitPolicyType", "descriptionDecl", 
                   "stringLiteral", "givenBlock", "inputParam", "paramName", 
                   "paramType", "baseType", "inlineComment", "decideBlock", 
                   "tableMatrix", "tableHeader", "priorityHeader", "columnHeader", 
                   "columnName", "tableSeparator", "tableRow", "priorityCell", 
                   "cell", "cellContent", "condition", "exactMatch", "rangeCondition", 
                   "setCondition", "patternCondition", "nullCondition", 
                   "comparisonCondition", "expressionCondition", "action", 
                   "assignAction", "calculateAction", "lookupAction", "callAction", 
                   "actionArg", "emitAction", "returnSpec", "returnParam", 
                   "executeSpec", "executeType", "hybridSpec", "postCalculateBlock", 
                   "postCalculateStatement", "assignmentStatement", "aggregateBlock", 
                   "aggregateStatement", "whenExpression", "proceduralRuleDef", 
                   "ruleName", "blockItem", "setStatement", "letStatement", 
                   "ruleStep", "block", "actionSequence", "actionCall", 
                   "parameterList", "parameter", "returnStatement", "booleanExpr", 
                   "booleanTerm", "booleanFactor", "comparisonExpr", "comparisonOp", 
                   "valueExpr", "term", "factor", "atom", "lambdaExpression", 
                   "arithmeticExpr", "functionCall", "fieldPath", "attributeIdentifier", 
                   "valueList", "listLiteral", "objectLiteral", "objectField", 
                   "objectFieldName", "literal", "numberLiteral" ]

    EOF = Token.EOF
    DECISION_TABLE=1
    RULE=2
    END=3
    GIVEN=4
    DECIDE=5
    RETURN=6
    EXECUTE=7
    HIT_POLICY=8
    FIRST_MATCH=9
    SINGLE_HIT=10
    MULTI_HIT=11
    COLLECT_ALL=12
    IF=13
    THEN=14
    ELSEIF=15
    ELSE=16
    ENDIF=17
    SET=18
    LET=19
    WHEN=20
    OTHERWISE=21
    POST_CALCULATE=22
    AGGREGATE=23
    AND=24
    OR=25
    NOT=26
    IN=27
    IS=28
    NULL=29
    IS_NULL=30
    IS_NOT_NULL=31
    MATCHES=32
    CONTAINS=33
    STARTS_WITH=34
    ENDS_WITH=35
    LOOKUP=36
    EMIT=37
    TO=38
    DEFAULT=39
    AS_OF=40
    TEXT_TYPE=41
    NUMBER_TYPE=42
    BOOLEAN_TYPE=43
    DATE_TYPE=44
    TIMESTAMP_TYPE=45
    MONEY_TYPE=46
    PERCENTAGE_TYPE=47
    DESCRIPTION=48
    PRIORITY=49
    VERSION=50
    YES=51
    MULTI=52
    EQ=53
    NE=54
    LT=55
    GT=56
    LE=57
    GE=58
    PLUS=59
    MINUS=60
    STAR=61
    SLASH=62
    PERCENT=63
    MOD=64
    ARROW=65
    PIPE=66
    COLON=67
    COMMA=68
    DOT=69
    LPAREN=70
    RPAREN=71
    LBRACKET=72
    RBRACKET=73
    LBRACE=74
    RBRACE=75
    SEP=76
    BOOLEAN=77
    VERSION_NUMBER=78
    INTEGER=79
    DECIMAL=80
    MONEY_LITERAL=81
    PERCENTAGE_LITERAL=82
    DQUOTED_STRING=83
    SQUOTED_STRING=84
    STRING=85
    IDENTIFIER=86
    LINE_COMMENT=87
    LINE_COMMENT_INLINE=88
    BLOCK_COMMENT=89
    WS=90

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(RulesDSLParser.EOF, 0)

        def decisionTableDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.DecisionTableDefContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.DecisionTableDefContext,i)


        def proceduralRuleDef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.ProceduralRuleDefContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.ProceduralRuleDefContext,i)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_program

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgram" ):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = RulesDSLParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 170 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 170
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [1]:
                    self.state = 168
                    self.decisionTableDef()
                    pass
                elif token in [2]:
                    self.state = 169
                    self.proceduralRuleDef()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 172 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==1 or _la==2):
                    break

            self.state = 174
            self.match(RulesDSLParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DecisionTableDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DECISION_TABLE(self):
            return self.getToken(RulesDSLParser.DECISION_TABLE, 0)

        def tableName(self):
            return self.getTypedRuleContext(RulesDSLParser.TableNameContext,0)


        def givenBlock(self):
            return self.getTypedRuleContext(RulesDSLParser.GivenBlockContext,0)


        def decideBlock(self):
            return self.getTypedRuleContext(RulesDSLParser.DecideBlockContext,0)


        def END(self):
            return self.getToken(RulesDSLParser.END, 0)

        def hitPolicyDecl(self):
            return self.getTypedRuleContext(RulesDSLParser.HitPolicyDeclContext,0)


        def descriptionDecl(self):
            return self.getTypedRuleContext(RulesDSLParser.DescriptionDeclContext,0)


        def versionDecl(self):
            return self.getTypedRuleContext(RulesDSLParser.VersionDeclContext,0)


        def returnSpec(self):
            return self.getTypedRuleContext(RulesDSLParser.ReturnSpecContext,0)


        def executeSpec(self):
            return self.getTypedRuleContext(RulesDSLParser.ExecuteSpecContext,0)


        def hybridSpec(self):
            return self.getTypedRuleContext(RulesDSLParser.HybridSpecContext,0)


        def postCalculateBlock(self):
            return self.getTypedRuleContext(RulesDSLParser.PostCalculateBlockContext,0)


        def aggregateBlock(self):
            return self.getTypedRuleContext(RulesDSLParser.AggregateBlockContext,0)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_decisionTableDef

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDecisionTableDef" ):
                return visitor.visitDecisionTableDef(self)
            else:
                return visitor.visitChildren(self)




    def decisionTableDef(self):

        localctx = RulesDSLParser.DecisionTableDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_decisionTableDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 176
            self.match(RulesDSLParser.DECISION_TABLE)
            self.state = 177
            self.tableName()
            self.state = 179
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8:
                self.state = 178
                self.hitPolicyDecl()


            self.state = 182
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==48:
                self.state = 181
                self.descriptionDecl()


            self.state = 185
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==50:
                self.state = 184
                self.versionDecl()


            self.state = 187
            self.givenBlock()
            self.state = 188
            self.decideBlock()
            self.state = 192
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.state = 189
                self.returnSpec()

            elif la_ == 2:
                self.state = 190
                self.executeSpec()

            elif la_ == 3:
                self.state = 191
                self.hybridSpec()


            self.state = 195
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==22:
                self.state = 194
                self.postCalculateBlock()


            self.state = 198
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==23:
                self.state = 197
                self.aggregateBlock()


            self.state = 200
            self.match(RulesDSLParser.END)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VersionDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VERSION(self):
            return self.getToken(RulesDSLParser.VERSION, 0)

        def COLON(self):
            return self.getToken(RulesDSLParser.COLON, 0)

        def VERSION_NUMBER(self):
            return self.getToken(RulesDSLParser.VERSION_NUMBER, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_versionDecl

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVersionDecl" ):
                return visitor.visitVersionDecl(self)
            else:
                return visitor.visitChildren(self)




    def versionDecl(self):

        localctx = RulesDSLParser.VersionDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_versionDecl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 202
            self.match(RulesDSLParser.VERSION)
            self.state = 203
            self.match(RulesDSLParser.COLON)
            self.state = 204
            self.match(RulesDSLParser.VERSION_NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RulesDSLParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_tableName

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableName" ):
                return visitor.visitTableName(self)
            else:
                return visitor.visitChildren(self)




    def tableName(self):

        localctx = RulesDSLParser.TableNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_tableName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 206
            self.match(RulesDSLParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HitPolicyDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HIT_POLICY(self):
            return self.getToken(RulesDSLParser.HIT_POLICY, 0)

        def hitPolicyType(self):
            return self.getTypedRuleContext(RulesDSLParser.HitPolicyTypeContext,0)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_hitPolicyDecl

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHitPolicyDecl" ):
                return visitor.visitHitPolicyDecl(self)
            else:
                return visitor.visitChildren(self)




    def hitPolicyDecl(self):

        localctx = RulesDSLParser.HitPolicyDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_hitPolicyDecl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 208
            self.match(RulesDSLParser.HIT_POLICY)
            self.state = 209
            self.hitPolicyType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HitPolicyTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FIRST_MATCH(self):
            return self.getToken(RulesDSLParser.FIRST_MATCH, 0)

        def SINGLE_HIT(self):
            return self.getToken(RulesDSLParser.SINGLE_HIT, 0)

        def MULTI_HIT(self):
            return self.getToken(RulesDSLParser.MULTI_HIT, 0)

        def COLLECT_ALL(self):
            return self.getToken(RulesDSLParser.COLLECT_ALL, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_hitPolicyType

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHitPolicyType" ):
                return visitor.visitHitPolicyType(self)
            else:
                return visitor.visitChildren(self)




    def hitPolicyType(self):

        localctx = RulesDSLParser.HitPolicyTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_hitPolicyType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 211
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 7680) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DescriptionDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DESCRIPTION(self):
            return self.getToken(RulesDSLParser.DESCRIPTION, 0)

        def stringLiteral(self):
            return self.getTypedRuleContext(RulesDSLParser.StringLiteralContext,0)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_descriptionDecl

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDescriptionDecl" ):
                return visitor.visitDescriptionDecl(self)
            else:
                return visitor.visitChildren(self)




    def descriptionDecl(self):

        localctx = RulesDSLParser.DescriptionDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_descriptionDecl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 213
            self.match(RulesDSLParser.DESCRIPTION)
            self.state = 214
            self.stringLiteral()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DQUOTED_STRING(self):
            return self.getToken(RulesDSLParser.DQUOTED_STRING, 0)

        def SQUOTED_STRING(self):
            return self.getToken(RulesDSLParser.SQUOTED_STRING, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_stringLiteral

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringLiteral" ):
                return visitor.visitStringLiteral(self)
            else:
                return visitor.visitChildren(self)




    def stringLiteral(self):

        localctx = RulesDSLParser.StringLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_stringLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 216
            _la = self._input.LA(1)
            if not(_la==83 or _la==84):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GivenBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GIVEN(self):
            return self.getToken(RulesDSLParser.GIVEN, 0)

        def COLON(self):
            return self.getToken(RulesDSLParser.COLON, 0)

        def inputParam(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.InputParamContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.InputParamContext,i)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_givenBlock

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGivenBlock" ):
                return visitor.visitGivenBlock(self)
            else:
                return visitor.visitChildren(self)




    def givenBlock(self):

        localctx = RulesDSLParser.GivenBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_givenBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 218
            self.match(RulesDSLParser.GIVEN)
            self.state = 219
            self.match(RulesDSLParser.COLON)
            self.state = 221 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 220
                self.inputParam()
                self.state = 223 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((((_la - 41)) & ~0x3f) == 0 and ((1 << (_la - 41)) & 35184372089729) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InputParamContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def paramName(self):
            return self.getTypedRuleContext(RulesDSLParser.ParamNameContext,0)


        def COLON(self):
            return self.getToken(RulesDSLParser.COLON, 0)

        def paramType(self):
            return self.getTypedRuleContext(RulesDSLParser.ParamTypeContext,0)


        def inlineComment(self):
            return self.getTypedRuleContext(RulesDSLParser.InlineCommentContext,0)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_inputParam

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInputParam" ):
                return visitor.visitInputParam(self)
            else:
                return visitor.visitChildren(self)




    def inputParam(self):

        localctx = RulesDSLParser.InputParamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_inputParam)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 225
            self.paramName()
            self.state = 226
            self.match(RulesDSLParser.COLON)
            self.state = 227
            self.paramType()
            self.state = 229
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==88:
                self.state = 228
                self.inlineComment()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParamNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RulesDSLParser.IDENTIFIER, 0)

        def PRIORITY(self):
            return self.getToken(RulesDSLParser.PRIORITY, 0)

        def DESCRIPTION(self):
            return self.getToken(RulesDSLParser.DESCRIPTION, 0)

        def TEXT_TYPE(self):
            return self.getToken(RulesDSLParser.TEXT_TYPE, 0)

        def VERSION(self):
            return self.getToken(RulesDSLParser.VERSION, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_paramName

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParamName" ):
                return visitor.visitParamName(self)
            else:
                return visitor.visitChildren(self)




    def paramName(self):

        localctx = RulesDSLParser.ParamNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_paramName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 231
            _la = self._input.LA(1)
            if not(((((_la - 41)) & ~0x3f) == 0 and ((1 << (_la - 41)) & 35184372089729) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParamTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def baseType(self):
            return self.getTypedRuleContext(RulesDSLParser.BaseTypeContext,0)


        def MONEY_TYPE(self):
            return self.getToken(RulesDSLParser.MONEY_TYPE, 0)

        def PERCENTAGE_TYPE(self):
            return self.getToken(RulesDSLParser.PERCENTAGE_TYPE, 0)

        def IDENTIFIER(self):
            return self.getToken(RulesDSLParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_paramType

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParamType" ):
                return visitor.visitParamType(self)
            else:
                return visitor.visitChildren(self)




    def paramType(self):

        localctx = RulesDSLParser.ParamTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_paramType)
        try:
            self.state = 237
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [41, 42, 43, 44, 45]:
                self.enterOuterAlt(localctx, 1)
                self.state = 233
                self.baseType()
                pass
            elif token in [46]:
                self.enterOuterAlt(localctx, 2)
                self.state = 234
                self.match(RulesDSLParser.MONEY_TYPE)
                pass
            elif token in [47]:
                self.enterOuterAlt(localctx, 3)
                self.state = 235
                self.match(RulesDSLParser.PERCENTAGE_TYPE)
                pass
            elif token in [86]:
                self.enterOuterAlt(localctx, 4)
                self.state = 236
                self.match(RulesDSLParser.IDENTIFIER)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BaseTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEXT_TYPE(self):
            return self.getToken(RulesDSLParser.TEXT_TYPE, 0)

        def NUMBER_TYPE(self):
            return self.getToken(RulesDSLParser.NUMBER_TYPE, 0)

        def BOOLEAN_TYPE(self):
            return self.getToken(RulesDSLParser.BOOLEAN_TYPE, 0)

        def DATE_TYPE(self):
            return self.getToken(RulesDSLParser.DATE_TYPE, 0)

        def TIMESTAMP_TYPE(self):
            return self.getToken(RulesDSLParser.TIMESTAMP_TYPE, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_baseType

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBaseType" ):
                return visitor.visitBaseType(self)
            else:
                return visitor.visitChildren(self)




    def baseType(self):

        localctx = RulesDSLParser.BaseTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_baseType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 239
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 68169720922112) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InlineCommentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LINE_COMMENT_INLINE(self):
            return self.getToken(RulesDSLParser.LINE_COMMENT_INLINE, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_inlineComment

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInlineComment" ):
                return visitor.visitInlineComment(self)
            else:
                return visitor.visitChildren(self)




    def inlineComment(self):

        localctx = RulesDSLParser.InlineCommentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_inlineComment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 241
            self.match(RulesDSLParser.LINE_COMMENT_INLINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DecideBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DECIDE(self):
            return self.getToken(RulesDSLParser.DECIDE, 0)

        def COLON(self):
            return self.getToken(RulesDSLParser.COLON, 0)

        def tableMatrix(self):
            return self.getTypedRuleContext(RulesDSLParser.TableMatrixContext,0)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_decideBlock

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDecideBlock" ):
                return visitor.visitDecideBlock(self)
            else:
                return visitor.visitChildren(self)




    def decideBlock(self):

        localctx = RulesDSLParser.DecideBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_decideBlock)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 243
            self.match(RulesDSLParser.DECIDE)
            self.state = 244
            self.match(RulesDSLParser.COLON)
            self.state = 245
            self.tableMatrix()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableMatrixContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tableHeader(self):
            return self.getTypedRuleContext(RulesDSLParser.TableHeaderContext,0)


        def tableSeparator(self):
            return self.getTypedRuleContext(RulesDSLParser.TableSeparatorContext,0)


        def tableRow(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.TableRowContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.TableRowContext,i)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_tableMatrix

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableMatrix" ):
                return visitor.visitTableMatrix(self)
            else:
                return visitor.visitChildren(self)




    def tableMatrix(self):

        localctx = RulesDSLParser.TableMatrixContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_tableMatrix)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 247
            self.tableHeader()
            self.state = 248
            self.tableSeparator()
            self.state = 250 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 249
                self.tableRow()
                self.state = 252 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==66):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableHeaderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PIPE(self):
            return self.getToken(RulesDSLParser.PIPE, 0)

        def priorityHeader(self):
            return self.getTypedRuleContext(RulesDSLParser.PriorityHeaderContext,0)


        def columnHeader(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.ColumnHeaderContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.ColumnHeaderContext,i)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_tableHeader

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableHeader" ):
                return visitor.visitTableHeader(self)
            else:
                return visitor.visitChildren(self)




    def tableHeader(self):

        localctx = RulesDSLParser.TableHeaderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_tableHeader)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 254
            self.match(RulesDSLParser.PIPE)
            self.state = 256
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.state = 255
                self.priorityHeader()


            self.state = 259 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 258
                self.columnHeader()
                self.state = 261 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 1973073616044096) != 0) or _la==86):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PriorityHeaderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PRIORITY(self):
            return self.getToken(RulesDSLParser.PRIORITY, 0)

        def PIPE(self):
            return self.getToken(RulesDSLParser.PIPE, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_priorityHeader

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPriorityHeader" ):
                return visitor.visitPriorityHeader(self)
            else:
                return visitor.visitChildren(self)




    def priorityHeader(self):

        localctx = RulesDSLParser.PriorityHeaderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_priorityHeader)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 263
            self.match(RulesDSLParser.PRIORITY)
            self.state = 264
            self.match(RulesDSLParser.PIPE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnHeaderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def columnName(self):
            return self.getTypedRuleContext(RulesDSLParser.ColumnNameContext,0)


        def PIPE(self):
            return self.getToken(RulesDSLParser.PIPE, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_columnHeader

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnHeader" ):
                return visitor.visitColumnHeader(self)
            else:
                return visitor.visitChildren(self)




    def columnHeader(self):

        localctx = RulesDSLParser.ColumnHeaderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_columnHeader)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 266
            self.columnName()
            self.state = 267
            self.match(RulesDSLParser.PIPE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColumnNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RulesDSLParser.IDENTIFIER, 0)

        def PRIORITY(self):
            return self.getToken(RulesDSLParser.PRIORITY, 0)

        def DESCRIPTION(self):
            return self.getToken(RulesDSLParser.DESCRIPTION, 0)

        def TEXT_TYPE(self):
            return self.getToken(RulesDSLParser.TEXT_TYPE, 0)

        def VERSION(self):
            return self.getToken(RulesDSLParser.VERSION, 0)

        def DEFAULT(self):
            return self.getToken(RulesDSLParser.DEFAULT, 0)

        def RETURN(self):
            return self.getToken(RulesDSLParser.RETURN, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_columnName

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnName" ):
                return visitor.visitColumnName(self)
            else:
                return visitor.visitChildren(self)




    def columnName(self):

        localctx = RulesDSLParser.ColumnNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_columnName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 269
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1973073616044096) != 0) or _la==86):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableSeparatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PIPE(self, i:int=None):
            if i is None:
                return self.getTokens(RulesDSLParser.PIPE)
            else:
                return self.getToken(RulesDSLParser.PIPE, i)

        def SEP(self):
            return self.getToken(RulesDSLParser.SEP, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_tableSeparator

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableSeparator" ):
                return visitor.visitTableSeparator(self)
            else:
                return visitor.visitChildren(self)




    def tableSeparator(self):

        localctx = RulesDSLParser.TableSeparatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_tableSeparator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 271
            self.match(RulesDSLParser.PIPE)
            self.state = 272
            self.match(RulesDSLParser.SEP)
            self.state = 273
            self.match(RulesDSLParser.PIPE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableRowContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PIPE(self):
            return self.getToken(RulesDSLParser.PIPE, 0)

        def priorityCell(self):
            return self.getTypedRuleContext(RulesDSLParser.PriorityCellContext,0)


        def cell(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.CellContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.CellContext,i)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_tableRow

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableRow" ):
                return visitor.visitTableRow(self)
            else:
                return visitor.visitChildren(self)




    def tableRow(self):

        localctx = RulesDSLParser.TableRowContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_tableRow)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 275
            self.match(RulesDSLParser.PIPE)
            self.state = 277
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.state = 276
                self.priorityCell()


            self.state = 280 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 279
                self.cell()
                self.state = 282 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((((_la - 26)) & ~0x3f) == 0 and ((1 << (_la - 26)) & 1722996353371475967) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PriorityCellContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER(self):
            return self.getToken(RulesDSLParser.INTEGER, 0)

        def PIPE(self):
            return self.getToken(RulesDSLParser.PIPE, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_priorityCell

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPriorityCell" ):
                return visitor.visitPriorityCell(self)
            else:
                return visitor.visitChildren(self)




    def priorityCell(self):

        localctx = RulesDSLParser.PriorityCellContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_priorityCell)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 284
            self.match(RulesDSLParser.INTEGER)
            self.state = 285
            self.match(RulesDSLParser.PIPE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CellContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cellContent(self):
            return self.getTypedRuleContext(RulesDSLParser.CellContentContext,0)


        def PIPE(self):
            return self.getToken(RulesDSLParser.PIPE, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_cell

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCell" ):
                return visitor.visitCell(self)
            else:
                return visitor.visitChildren(self)




    def cell(self):

        localctx = RulesDSLParser.CellContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_cell)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 287
            self.cellContent()
            self.state = 288
            self.match(RulesDSLParser.PIPE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CellContentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition(self):
            return self.getTypedRuleContext(RulesDSLParser.ConditionContext,0)


        def action(self):
            return self.getTypedRuleContext(RulesDSLParser.ActionContext,0)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_cellContent

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCellContent" ):
                return visitor.visitCellContent(self)
            else:
                return visitor.visitChildren(self)




    def cellContent(self):

        localctx = RulesDSLParser.CellContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_cellContent)
        try:
            self.state = 292
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 290
                self.condition()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 291
                self.action()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STAR(self):
            return self.getToken(RulesDSLParser.STAR, 0)

        def exactMatch(self):
            return self.getTypedRuleContext(RulesDSLParser.ExactMatchContext,0)


        def rangeCondition(self):
            return self.getTypedRuleContext(RulesDSLParser.RangeConditionContext,0)


        def setCondition(self):
            return self.getTypedRuleContext(RulesDSLParser.SetConditionContext,0)


        def patternCondition(self):
            return self.getTypedRuleContext(RulesDSLParser.PatternConditionContext,0)


        def nullCondition(self):
            return self.getTypedRuleContext(RulesDSLParser.NullConditionContext,0)


        def comparisonCondition(self):
            return self.getTypedRuleContext(RulesDSLParser.ComparisonConditionContext,0)


        def expressionCondition(self):
            return self.getTypedRuleContext(RulesDSLParser.ExpressionConditionContext,0)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_condition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCondition" ):
                return visitor.visitCondition(self)
            else:
                return visitor.visitChildren(self)




    def condition(self):

        localctx = RulesDSLParser.ConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_condition)
        try:
            self.state = 302
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 294
                self.match(RulesDSLParser.STAR)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 295
                self.exactMatch()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 296
                self.rangeCondition()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 297
                self.setCondition()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 298
                self.patternCondition()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 299
                self.nullCondition()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 300
                self.comparisonCondition()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 301
                self.expressionCondition()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExactMatchContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def literal(self):
            return self.getTypedRuleContext(RulesDSLParser.LiteralContext,0)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_exactMatch

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExactMatch" ):
                return visitor.visitExactMatch(self)
            else:
                return visitor.visitChildren(self)




    def exactMatch(self):

        localctx = RulesDSLParser.ExactMatchContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_exactMatch)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 304
            self.literal()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RangeConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numberLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.NumberLiteralContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.NumberLiteralContext,i)


        def TO(self):
            return self.getToken(RulesDSLParser.TO, 0)

        def MONEY_LITERAL(self, i:int=None):
            if i is None:
                return self.getTokens(RulesDSLParser.MONEY_LITERAL)
            else:
                return self.getToken(RulesDSLParser.MONEY_LITERAL, i)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_rangeCondition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRangeCondition" ):
                return visitor.visitRangeCondition(self)
            else:
                return visitor.visitChildren(self)




    def rangeCondition(self):

        localctx = RulesDSLParser.RangeConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_rangeCondition)
        try:
            self.state = 313
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [60, 79, 80]:
                self.enterOuterAlt(localctx, 1)
                self.state = 306
                self.numberLiteral()
                self.state = 307
                self.match(RulesDSLParser.TO)
                self.state = 308
                self.numberLiteral()
                pass
            elif token in [81]:
                self.enterOuterAlt(localctx, 2)
                self.state = 310
                self.match(RulesDSLParser.MONEY_LITERAL)
                self.state = 311
                self.match(RulesDSLParser.TO)
                self.state = 312
                self.match(RulesDSLParser.MONEY_LITERAL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IN(self):
            return self.getToken(RulesDSLParser.IN, 0)

        def LPAREN(self):
            return self.getToken(RulesDSLParser.LPAREN, 0)

        def valueList(self):
            return self.getTypedRuleContext(RulesDSLParser.ValueListContext,0)


        def RPAREN(self):
            return self.getToken(RulesDSLParser.RPAREN, 0)

        def NOT(self):
            return self.getToken(RulesDSLParser.NOT, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_setCondition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetCondition" ):
                return visitor.visitSetCondition(self)
            else:
                return visitor.visitChildren(self)




    def setCondition(self):

        localctx = RulesDSLParser.SetConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_setCondition)
        try:
            self.state = 326
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [27]:
                self.enterOuterAlt(localctx, 1)
                self.state = 315
                self.match(RulesDSLParser.IN)
                self.state = 316
                self.match(RulesDSLParser.LPAREN)
                self.state = 317
                self.valueList()
                self.state = 318
                self.match(RulesDSLParser.RPAREN)
                pass
            elif token in [26]:
                self.enterOuterAlt(localctx, 2)
                self.state = 320
                self.match(RulesDSLParser.NOT)
                self.state = 321
                self.match(RulesDSLParser.IN)
                self.state = 322
                self.match(RulesDSLParser.LPAREN)
                self.state = 323
                self.valueList()
                self.state = 324
                self.match(RulesDSLParser.RPAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PatternConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MATCHES(self):
            return self.getToken(RulesDSLParser.MATCHES, 0)

        def stringLiteral(self):
            return self.getTypedRuleContext(RulesDSLParser.StringLiteralContext,0)


        def ENDS_WITH(self):
            return self.getToken(RulesDSLParser.ENDS_WITH, 0)

        def STARTS_WITH(self):
            return self.getToken(RulesDSLParser.STARTS_WITH, 0)

        def CONTAINS(self):
            return self.getToken(RulesDSLParser.CONTAINS, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_patternCondition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPatternCondition" ):
                return visitor.visitPatternCondition(self)
            else:
                return visitor.visitChildren(self)




    def patternCondition(self):

        localctx = RulesDSLParser.PatternConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_patternCondition)
        try:
            self.state = 336
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [32]:
                self.enterOuterAlt(localctx, 1)
                self.state = 328
                self.match(RulesDSLParser.MATCHES)
                self.state = 329
                self.stringLiteral()
                pass
            elif token in [35]:
                self.enterOuterAlt(localctx, 2)
                self.state = 330
                self.match(RulesDSLParser.ENDS_WITH)
                self.state = 331
                self.stringLiteral()
                pass
            elif token in [34]:
                self.enterOuterAlt(localctx, 3)
                self.state = 332
                self.match(RulesDSLParser.STARTS_WITH)
                self.state = 333
                self.stringLiteral()
                pass
            elif token in [33]:
                self.enterOuterAlt(localctx, 4)
                self.state = 334
                self.match(RulesDSLParser.CONTAINS)
                self.state = 335
                self.stringLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NullConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IS(self):
            return self.getToken(RulesDSLParser.IS, 0)

        def NULL(self):
            return self.getToken(RulesDSLParser.NULL, 0)

        def NOT(self):
            return self.getToken(RulesDSLParser.NOT, 0)

        def IS_NULL(self):
            return self.getToken(RulesDSLParser.IS_NULL, 0)

        def IS_NOT_NULL(self):
            return self.getToken(RulesDSLParser.IS_NOT_NULL, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_nullCondition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNullCondition" ):
                return visitor.visitNullCondition(self)
            else:
                return visitor.visitChildren(self)




    def nullCondition(self):

        localctx = RulesDSLParser.NullConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_nullCondition)
        try:
            self.state = 345
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,21,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 338
                self.match(RulesDSLParser.IS)
                self.state = 339
                self.match(RulesDSLParser.NULL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 340
                self.match(RulesDSLParser.IS)
                self.state = 341
                self.match(RulesDSLParser.NOT)
                self.state = 342
                self.match(RulesDSLParser.NULL)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 343
                self.match(RulesDSLParser.IS_NULL)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 344
                self.match(RulesDSLParser.IS_NOT_NULL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def comparisonOp(self):
            return self.getTypedRuleContext(RulesDSLParser.ComparisonOpContext,0)


        def valueExpr(self):
            return self.getTypedRuleContext(RulesDSLParser.ValueExprContext,0)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_comparisonCondition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparisonCondition" ):
                return visitor.visitComparisonCondition(self)
            else:
                return visitor.visitChildren(self)




    def comparisonCondition(self):

        localctx = RulesDSLParser.ComparisonConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_comparisonCondition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 347
            self.comparisonOp()
            self.state = 348
            self.valueExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(RulesDSLParser.LPAREN, 0)

        def booleanExpr(self):
            return self.getTypedRuleContext(RulesDSLParser.BooleanExprContext,0)


        def RPAREN(self):
            return self.getToken(RulesDSLParser.RPAREN, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_expressionCondition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressionCondition" ):
                return visitor.visitExpressionCondition(self)
            else:
                return visitor.visitChildren(self)




    def expressionCondition(self):

        localctx = RulesDSLParser.ExpressionConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_expressionCondition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 350
            self.match(RulesDSLParser.LPAREN)
            self.state = 351
            self.booleanExpr()
            self.state = 352
            self.match(RulesDSLParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STAR(self):
            return self.getToken(RulesDSLParser.STAR, 0)

        def assignAction(self):
            return self.getTypedRuleContext(RulesDSLParser.AssignActionContext,0)


        def calculateAction(self):
            return self.getTypedRuleContext(RulesDSLParser.CalculateActionContext,0)


        def lookupAction(self):
            return self.getTypedRuleContext(RulesDSLParser.LookupActionContext,0)


        def callAction(self):
            return self.getTypedRuleContext(RulesDSLParser.CallActionContext,0)


        def emitAction(self):
            return self.getTypedRuleContext(RulesDSLParser.EmitActionContext,0)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_action

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction" ):
                return visitor.visitAction(self)
            else:
                return visitor.visitChildren(self)




    def action(self):

        localctx = RulesDSLParser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_action)
        try:
            self.state = 360
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 354
                self.match(RulesDSLParser.STAR)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 355
                self.assignAction()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 356
                self.calculateAction()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 357
                self.lookupAction()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 358
                self.callAction()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 359
                self.emitAction()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignActionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def literal(self):
            return self.getTypedRuleContext(RulesDSLParser.LiteralContext,0)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_assignAction

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignAction" ):
                return visitor.visitAssignAction(self)
            else:
                return visitor.visitChildren(self)




    def assignAction(self):

        localctx = RulesDSLParser.AssignActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_assignAction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 362
            self.literal()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CalculateActionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arithmeticExpr(self):
            return self.getTypedRuleContext(RulesDSLParser.ArithmeticExprContext,0)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_calculateAction

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCalculateAction" ):
                return visitor.visitCalculateAction(self)
            else:
                return visitor.visitChildren(self)




    def calculateAction(self):

        localctx = RulesDSLParser.CalculateActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_calculateAction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 364
            self.arithmeticExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LookupActionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LOOKUP(self):
            return self.getToken(RulesDSLParser.LOOKUP, 0)

        def LPAREN(self):
            return self.getToken(RulesDSLParser.LPAREN, 0)

        def IDENTIFIER(self):
            return self.getToken(RulesDSLParser.IDENTIFIER, 0)

        def RPAREN(self):
            return self.getToken(RulesDSLParser.RPAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RulesDSLParser.COMMA)
            else:
                return self.getToken(RulesDSLParser.COMMA, i)

        def valueExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.ValueExprContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.ValueExprContext,i)


        def DEFAULT(self):
            return self.getToken(RulesDSLParser.DEFAULT, 0)

        def COLON(self):
            return self.getToken(RulesDSLParser.COLON, 0)

        def AS_OF(self):
            return self.getToken(RulesDSLParser.AS_OF, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_lookupAction

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLookupAction" ):
                return visitor.visitLookupAction(self)
            else:
                return visitor.visitChildren(self)




    def lookupAction(self):

        localctx = RulesDSLParser.LookupActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_lookupAction)
        self._la = 0 # Token type
        try:
            self.state = 392
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 366
                self.match(RulesDSLParser.LOOKUP)
                self.state = 367
                self.match(RulesDSLParser.LPAREN)
                self.state = 368
                self.match(RulesDSLParser.IDENTIFIER)
                self.state = 373
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,23,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 369
                        self.match(RulesDSLParser.COMMA)
                        self.state = 370
                        self.valueExpr() 
                    self.state = 375
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,23,self._ctx)

                self.state = 380
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==68:
                    self.state = 376
                    self.match(RulesDSLParser.COMMA)
                    self.state = 377
                    self.match(RulesDSLParser.DEFAULT)
                    self.state = 378
                    self.match(RulesDSLParser.COLON)
                    self.state = 379
                    self.valueExpr()


                self.state = 382
                self.match(RulesDSLParser.RPAREN)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 383
                self.match(RulesDSLParser.LOOKUP)
                self.state = 384
                self.match(RulesDSLParser.LPAREN)
                self.state = 385
                self.match(RulesDSLParser.IDENTIFIER)
                self.state = 386
                self.match(RulesDSLParser.COMMA)
                self.state = 387
                self.match(RulesDSLParser.AS_OF)
                self.state = 388
                self.match(RulesDSLParser.COLON)
                self.state = 389
                self.valueExpr()
                self.state = 390
                self.match(RulesDSLParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CallActionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RulesDSLParser.IDENTIFIER, 0)

        def LPAREN(self):
            return self.getToken(RulesDSLParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(RulesDSLParser.RPAREN, 0)

        def actionArg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.ActionArgContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.ActionArgContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RulesDSLParser.COMMA)
            else:
                return self.getToken(RulesDSLParser.COMMA, i)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_callAction

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCallAction" ):
                return visitor.visitCallAction(self)
            else:
                return visitor.visitChildren(self)




    def callAction(self):

        localctx = RulesDSLParser.CallActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_callAction)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 394
            self.match(RulesDSLParser.IDENTIFIER)
            self.state = 395
            self.match(RulesDSLParser.LPAREN)
            self.state = 404
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 29)) & ~0x3f) == 0 and ((1 << (_la - 29)) & 215374538819502081) != 0):
                self.state = 396
                self.actionArg()
                self.state = 401
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==68:
                    self.state = 397
                    self.match(RulesDSLParser.COMMA)
                    self.state = 398
                    self.actionArg()
                    self.state = 403
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 406
            self.match(RulesDSLParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionArgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def valueExpr(self):
            return self.getTypedRuleContext(RulesDSLParser.ValueExprContext,0)


        def IDENTIFIER(self):
            return self.getToken(RulesDSLParser.IDENTIFIER, 0)

        def COLON(self):
            return self.getToken(RulesDSLParser.COLON, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_actionArg

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitActionArg" ):
                return visitor.visitActionArg(self)
            else:
                return visitor.visitChildren(self)




    def actionArg(self):

        localctx = RulesDSLParser.ActionArgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_actionArg)
        try:
            self.state = 412
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,28,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 408
                self.valueExpr()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 409
                self.match(RulesDSLParser.IDENTIFIER)
                self.state = 410
                self.match(RulesDSLParser.COLON)
                self.state = 411
                self.valueExpr()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EmitActionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EMIT(self):
            return self.getToken(RulesDSLParser.EMIT, 0)

        def TO(self):
            return self.getToken(RulesDSLParser.TO, 0)

        def IDENTIFIER(self):
            return self.getToken(RulesDSLParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_emitAction

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEmitAction" ):
                return visitor.visitEmitAction(self)
            else:
                return visitor.visitChildren(self)




    def emitAction(self):

        localctx = RulesDSLParser.EmitActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_emitAction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 414
            self.match(RulesDSLParser.EMIT)
            self.state = 415
            self.match(RulesDSLParser.TO)
            self.state = 416
            self.match(RulesDSLParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnSpecContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURN(self):
            return self.getToken(RulesDSLParser.RETURN, 0)

        def COLON(self):
            return self.getToken(RulesDSLParser.COLON, 0)

        def returnParam(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.ReturnParamContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.ReturnParamContext,i)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_returnSpec

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturnSpec" ):
                return visitor.visitReturnSpec(self)
            else:
                return visitor.visitChildren(self)




    def returnSpec(self):

        localctx = RulesDSLParser.ReturnSpecContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_returnSpec)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 418
            self.match(RulesDSLParser.RETURN)
            self.state = 419
            self.match(RulesDSLParser.COLON)
            self.state = 421 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 420
                self.returnParam()
                self.state = 423 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((((_la - 41)) & ~0x3f) == 0 and ((1 << (_la - 41)) & 35184372089729) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnParamContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def paramName(self):
            return self.getTypedRuleContext(RulesDSLParser.ParamNameContext,0)


        def COLON(self):
            return self.getToken(RulesDSLParser.COLON, 0)

        def paramType(self):
            return self.getTypedRuleContext(RulesDSLParser.ParamTypeContext,0)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_returnParam

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturnParam" ):
                return visitor.visitReturnParam(self)
            else:
                return visitor.visitChildren(self)




    def returnParam(self):

        localctx = RulesDSLParser.ReturnParamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_returnParam)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 425
            self.paramName()
            self.state = 426
            self.match(RulesDSLParser.COLON)
            self.state = 427
            self.paramType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExecuteSpecContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXECUTE(self):
            return self.getToken(RulesDSLParser.EXECUTE, 0)

        def COLON(self):
            return self.getToken(RulesDSLParser.COLON, 0)

        def executeType(self):
            return self.getTypedRuleContext(RulesDSLParser.ExecuteTypeContext,0)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_executeSpec

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExecuteSpec" ):
                return visitor.visitExecuteSpec(self)
            else:
                return visitor.visitChildren(self)




    def executeSpec(self):

        localctx = RulesDSLParser.ExecuteSpecContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_executeSpec)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 429
            self.match(RulesDSLParser.EXECUTE)
            self.state = 430
            self.match(RulesDSLParser.COLON)
            self.state = 431
            self.executeType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExecuteTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def YES(self):
            return self.getToken(RulesDSLParser.YES, 0)

        def MULTI(self):
            return self.getToken(RulesDSLParser.MULTI, 0)

        def IDENTIFIER(self):
            return self.getToken(RulesDSLParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_executeType

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExecuteType" ):
                return visitor.visitExecuteType(self)
            else:
                return visitor.visitChildren(self)




    def executeType(self):

        localctx = RulesDSLParser.ExecuteTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_executeType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 433
            _la = self._input.LA(1)
            if not(((((_la - 51)) & ~0x3f) == 0 and ((1 << (_la - 51)) & 34359738371) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HybridSpecContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def returnSpec(self):
            return self.getTypedRuleContext(RulesDSLParser.ReturnSpecContext,0)


        def executeSpec(self):
            return self.getTypedRuleContext(RulesDSLParser.ExecuteSpecContext,0)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_hybridSpec

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHybridSpec" ):
                return visitor.visitHybridSpec(self)
            else:
                return visitor.visitChildren(self)




    def hybridSpec(self):

        localctx = RulesDSLParser.HybridSpecContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_hybridSpec)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 435
            self.returnSpec()
            self.state = 436
            self.executeSpec()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PostCalculateBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POST_CALCULATE(self):
            return self.getToken(RulesDSLParser.POST_CALCULATE, 0)

        def COLON(self):
            return self.getToken(RulesDSLParser.COLON, 0)

        def postCalculateStatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.PostCalculateStatementContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.PostCalculateStatementContext,i)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_postCalculateBlock

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPostCalculateBlock" ):
                return visitor.visitPostCalculateBlock(self)
            else:
                return visitor.visitChildren(self)




    def postCalculateBlock(self):

        localctx = RulesDSLParser.PostCalculateBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_postCalculateBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 438
            self.match(RulesDSLParser.POST_CALCULATE)
            self.state = 439
            self.match(RulesDSLParser.COLON)
            self.state = 441 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 440
                self.postCalculateStatement()
                self.state = 443 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==19 or _la==86):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PostCalculateStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def letStatement(self):
            return self.getTypedRuleContext(RulesDSLParser.LetStatementContext,0)


        def assignmentStatement(self):
            return self.getTypedRuleContext(RulesDSLParser.AssignmentStatementContext,0)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_postCalculateStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPostCalculateStatement" ):
                return visitor.visitPostCalculateStatement(self)
            else:
                return visitor.visitChildren(self)




    def postCalculateStatement(self):

        localctx = RulesDSLParser.PostCalculateStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_postCalculateStatement)
        try:
            self.state = 447
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [19]:
                self.enterOuterAlt(localctx, 1)
                self.state = 445
                self.letStatement()
                pass
            elif token in [86]:
                self.enterOuterAlt(localctx, 2)
                self.state = 446
                self.assignmentStatement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RulesDSLParser.IDENTIFIER, 0)

        def EQ(self):
            return self.getToken(RulesDSLParser.EQ, 0)

        def valueExpr(self):
            return self.getTypedRuleContext(RulesDSLParser.ValueExprContext,0)


        def whenExpression(self):
            return self.getTypedRuleContext(RulesDSLParser.WhenExpressionContext,0)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_assignmentStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignmentStatement" ):
                return visitor.visitAssignmentStatement(self)
            else:
                return visitor.visitChildren(self)




    def assignmentStatement(self):

        localctx = RulesDSLParser.AssignmentStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_assignmentStatement)
        try:
            self.state = 455
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,32,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 449
                self.match(RulesDSLParser.IDENTIFIER)
                self.state = 450
                self.match(RulesDSLParser.EQ)
                self.state = 451
                self.valueExpr()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 452
                self.match(RulesDSLParser.IDENTIFIER)
                self.state = 453
                self.match(RulesDSLParser.EQ)
                self.state = 454
                self.whenExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregateBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AGGREGATE(self):
            return self.getToken(RulesDSLParser.AGGREGATE, 0)

        def COLON(self):
            return self.getToken(RulesDSLParser.COLON, 0)

        def aggregateStatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.AggregateStatementContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.AggregateStatementContext,i)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_aggregateBlock

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregateBlock" ):
                return visitor.visitAggregateBlock(self)
            else:
                return visitor.visitChildren(self)




    def aggregateBlock(self):

        localctx = RulesDSLParser.AggregateBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_aggregateBlock)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 457
            self.match(RulesDSLParser.AGGREGATE)
            self.state = 458
            self.match(RulesDSLParser.COLON)
            self.state = 460 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 459
                self.aggregateStatement()
                self.state = 462 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==86):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregateStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RulesDSLParser.IDENTIFIER, 0)

        def EQ(self):
            return self.getToken(RulesDSLParser.EQ, 0)

        def valueExpr(self):
            return self.getTypedRuleContext(RulesDSLParser.ValueExprContext,0)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_aggregateStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregateStatement" ):
                return visitor.visitAggregateStatement(self)
            else:
                return visitor.visitChildren(self)




    def aggregateStatement(self):

        localctx = RulesDSLParser.AggregateStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_aggregateStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 464
            self.match(RulesDSLParser.IDENTIFIER)
            self.state = 465
            self.match(RulesDSLParser.EQ)
            self.state = 466
            self.valueExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhenExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHEN(self, i:int=None):
            if i is None:
                return self.getTokens(RulesDSLParser.WHEN)
            else:
                return self.getToken(RulesDSLParser.WHEN, i)

        def booleanExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.BooleanExprContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.BooleanExprContext,i)


        def THEN(self, i:int=None):
            if i is None:
                return self.getTokens(RulesDSLParser.THEN)
            else:
                return self.getToken(RulesDSLParser.THEN, i)

        def valueExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.ValueExprContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.ValueExprContext,i)


        def OTHERWISE(self):
            return self.getToken(RulesDSLParser.OTHERWISE, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_whenExpression

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhenExpression" ):
                return visitor.visitWhenExpression(self)
            else:
                return visitor.visitChildren(self)




    def whenExpression(self):

        localctx = RulesDSLParser.WhenExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_whenExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 468
            self.match(RulesDSLParser.WHEN)
            self.state = 469
            self.booleanExpr()
            self.state = 470
            self.match(RulesDSLParser.THEN)
            self.state = 471
            self.valueExpr()
            self.state = 479
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==20:
                self.state = 472
                self.match(RulesDSLParser.WHEN)
                self.state = 473
                self.booleanExpr()
                self.state = 474
                self.match(RulesDSLParser.THEN)
                self.state = 475
                self.valueExpr()
                self.state = 481
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 482
            self.match(RulesDSLParser.OTHERWISE)
            self.state = 483
            self.valueExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProceduralRuleDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RULE(self):
            return self.getToken(RulesDSLParser.RULE, 0)

        def ruleName(self):
            return self.getTypedRuleContext(RulesDSLParser.RuleNameContext,0)


        def COLON(self):
            return self.getToken(RulesDSLParser.COLON, 0)

        def END(self):
            return self.getToken(RulesDSLParser.END, 0)

        def descriptionDecl(self):
            return self.getTypedRuleContext(RulesDSLParser.DescriptionDeclContext,0)


        def blockItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.BlockItemContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.BlockItemContext,i)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_proceduralRuleDef

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProceduralRuleDef" ):
                return visitor.visitProceduralRuleDef(self)
            else:
                return visitor.visitChildren(self)




    def proceduralRuleDef(self):

        localctx = RulesDSLParser.ProceduralRuleDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_proceduralRuleDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 485
            self.match(RulesDSLParser.RULE)
            self.state = 486
            self.ruleName()
            self.state = 487
            self.match(RulesDSLParser.COLON)
            self.state = 489
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==48:
                self.state = 488
                self.descriptionDecl()


            self.state = 492 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 491
                self.blockItem()
                self.state = 494 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 794688) != 0) or _la==83 or _la==86):
                    break

            self.state = 496
            self.match(RulesDSLParser.END)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RulesDSLParser.IDENTIFIER, 0)

        def DQUOTED_STRING(self):
            return self.getToken(RulesDSLParser.DQUOTED_STRING, 0)

        def SQUOTED_STRING(self):
            return self.getToken(RulesDSLParser.SQUOTED_STRING, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_ruleName

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRuleName" ):
                return visitor.visitRuleName(self)
            else:
                return visitor.visitChildren(self)




    def ruleName(self):

        localctx = RulesDSLParser.RuleNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_ruleName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 498
            _la = self._input.LA(1)
            if not(((((_la - 83)) & ~0x3f) == 0 and ((1 << (_la - 83)) & 11) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlockItemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ruleStep(self):
            return self.getTypedRuleContext(RulesDSLParser.RuleStepContext,0)


        def setStatement(self):
            return self.getTypedRuleContext(RulesDSLParser.SetStatementContext,0)


        def letStatement(self):
            return self.getTypedRuleContext(RulesDSLParser.LetStatementContext,0)


        def actionSequence(self):
            return self.getTypedRuleContext(RulesDSLParser.ActionSequenceContext,0)


        def returnStatement(self):
            return self.getTypedRuleContext(RulesDSLParser.ReturnStatementContext,0)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_blockItem

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlockItem" ):
                return visitor.visitBlockItem(self)
            else:
                return visitor.visitChildren(self)




    def blockItem(self):

        localctx = RulesDSLParser.BlockItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_blockItem)
        try:
            self.state = 505
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [13]:
                self.enterOuterAlt(localctx, 1)
                self.state = 500
                self.ruleStep()
                pass
            elif token in [18]:
                self.enterOuterAlt(localctx, 2)
                self.state = 501
                self.setStatement()
                pass
            elif token in [19]:
                self.enterOuterAlt(localctx, 3)
                self.state = 502
                self.letStatement()
                pass
            elif token in [83, 86]:
                self.enterOuterAlt(localctx, 4)
                self.state = 503
                self.actionSequence()
                pass
            elif token in [6]:
                self.enterOuterAlt(localctx, 5)
                self.state = 504
                self.returnStatement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET(self):
            return self.getToken(RulesDSLParser.SET, 0)

        def IDENTIFIER(self):
            return self.getToken(RulesDSLParser.IDENTIFIER, 0)

        def EQ(self):
            return self.getToken(RulesDSLParser.EQ, 0)

        def valueExpr(self):
            return self.getTypedRuleContext(RulesDSLParser.ValueExprContext,0)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_setStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetStatement" ):
                return visitor.visitSetStatement(self)
            else:
                return visitor.visitChildren(self)




    def setStatement(self):

        localctx = RulesDSLParser.SetStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_setStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 507
            self.match(RulesDSLParser.SET)
            self.state = 508
            self.match(RulesDSLParser.IDENTIFIER)
            self.state = 509
            self.match(RulesDSLParser.EQ)
            self.state = 510
            self.valueExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LetStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LET(self):
            return self.getToken(RulesDSLParser.LET, 0)

        def IDENTIFIER(self):
            return self.getToken(RulesDSLParser.IDENTIFIER, 0)

        def EQ(self):
            return self.getToken(RulesDSLParser.EQ, 0)

        def valueExpr(self):
            return self.getTypedRuleContext(RulesDSLParser.ValueExprContext,0)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_letStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLetStatement" ):
                return visitor.visitLetStatement(self)
            else:
                return visitor.visitChildren(self)




    def letStatement(self):

        localctx = RulesDSLParser.LetStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_letStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 512
            self.match(RulesDSLParser.LET)
            self.state = 513
            self.match(RulesDSLParser.IDENTIFIER)
            self.state = 514
            self.match(RulesDSLParser.EQ)
            self.state = 515
            self.valueExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RuleStepContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(RulesDSLParser.IF, 0)

        def booleanExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.BooleanExprContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.BooleanExprContext,i)


        def THEN(self, i:int=None):
            if i is None:
                return self.getTokens(RulesDSLParser.THEN)
            else:
                return self.getToken(RulesDSLParser.THEN, i)

        def block(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.BlockContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.BlockContext,i)


        def ENDIF(self):
            return self.getToken(RulesDSLParser.ENDIF, 0)

        def ELSEIF(self, i:int=None):
            if i is None:
                return self.getTokens(RulesDSLParser.ELSEIF)
            else:
                return self.getToken(RulesDSLParser.ELSEIF, i)

        def ELSE(self):
            return self.getToken(RulesDSLParser.ELSE, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_ruleStep

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRuleStep" ):
                return visitor.visitRuleStep(self)
            else:
                return visitor.visitChildren(self)




    def ruleStep(self):

        localctx = RulesDSLParser.RuleStepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_ruleStep)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 517
            self.match(RulesDSLParser.IF)
            self.state = 518
            self.booleanExpr()
            self.state = 519
            self.match(RulesDSLParser.THEN)
            self.state = 520
            self.block()
            self.state = 528
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==15:
                self.state = 521
                self.match(RulesDSLParser.ELSEIF)
                self.state = 522
                self.booleanExpr()
                self.state = 523
                self.match(RulesDSLParser.THEN)
                self.state = 524
                self.block()
                self.state = 530
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 533
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==16:
                self.state = 531
                self.match(RulesDSLParser.ELSE)
                self.state = 532
                self.block()


            self.state = 535
            self.match(RulesDSLParser.ENDIF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def blockItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.BlockItemContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.BlockItemContext,i)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_block

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlock" ):
                return visitor.visitBlock(self)
            else:
                return visitor.visitChildren(self)




    def block(self):

        localctx = RulesDSLParser.BlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_block)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 538 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 537
                self.blockItem()
                self.state = 540 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 794688) != 0) or _la==83 or _la==86):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionSequenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def actionCall(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.ActionCallContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.ActionCallContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RulesDSLParser.COMMA)
            else:
                return self.getToken(RulesDSLParser.COMMA, i)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_actionSequence

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitActionSequence" ):
                return visitor.visitActionSequence(self)
            else:
                return visitor.visitChildren(self)




    def actionSequence(self):

        localctx = RulesDSLParser.ActionSequenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_actionSequence)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 542
            self.actionCall()
            self.state = 547
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==68:
                self.state = 543
                self.match(RulesDSLParser.COMMA)
                self.state = 544
                self.actionCall()
                self.state = 549
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RulesDSLParser.IDENTIFIER, 0)

        def LPAREN(self):
            return self.getToken(RulesDSLParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(RulesDSLParser.RPAREN, 0)

        def parameterList(self):
            return self.getTypedRuleContext(RulesDSLParser.ParameterListContext,0)


        def DQUOTED_STRING(self):
            return self.getToken(RulesDSLParser.DQUOTED_STRING, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_actionCall

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitActionCall" ):
                return visitor.visitActionCall(self)
            else:
                return visitor.visitChildren(self)




    def actionCall(self):

        localctx = RulesDSLParser.ActionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_actionCall)
        self._la = 0 # Token type
        try:
            self.state = 566
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [86]:
                self.enterOuterAlt(localctx, 1)
                self.state = 550
                self.match(RulesDSLParser.IDENTIFIER)
                self.state = 556
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==70:
                    self.state = 551
                    self.match(RulesDSLParser.LPAREN)
                    self.state = 553
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if ((((_la - 29)) & ~0x3f) == 0 and ((1 << (_la - 29)) & 215374538819502081) != 0):
                        self.state = 552
                        self.parameterList()


                    self.state = 555
                    self.match(RulesDSLParser.RPAREN)


                pass
            elif token in [83]:
                self.enterOuterAlt(localctx, 2)
                self.state = 558
                self.match(RulesDSLParser.DQUOTED_STRING)
                self.state = 564
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==70:
                    self.state = 559
                    self.match(RulesDSLParser.LPAREN)
                    self.state = 561
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if ((((_la - 29)) & ~0x3f) == 0 and ((1 << (_la - 29)) & 215374538819502081) != 0):
                        self.state = 560
                        self.parameterList()


                    self.state = 563
                    self.match(RulesDSLParser.RPAREN)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def parameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.ParameterContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.ParameterContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RulesDSLParser.COMMA)
            else:
                return self.getToken(RulesDSLParser.COMMA, i)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_parameterList

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameterList" ):
                return visitor.visitParameterList(self)
            else:
                return visitor.visitChildren(self)




    def parameterList(self):

        localctx = RulesDSLParser.ParameterListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_parameterList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 568
            self.parameter()
            self.state = 573
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==68:
                self.state = 569
                self.match(RulesDSLParser.COMMA)
                self.state = 570
                self.parameter()
                self.state = 575
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def valueExpr(self):
            return self.getTypedRuleContext(RulesDSLParser.ValueExprContext,0)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_parameter

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameter" ):
                return visitor.visitParameter(self)
            else:
                return visitor.visitChildren(self)




    def parameter(self):

        localctx = RulesDSLParser.ParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 576
            self.valueExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURN(self):
            return self.getToken(RulesDSLParser.RETURN, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_returnStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturnStatement" ):
                return visitor.visitReturnStatement(self)
            else:
                return visitor.visitChildren(self)




    def returnStatement(self):

        localctx = RulesDSLParser.ReturnStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_returnStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 578
            self.match(RulesDSLParser.RETURN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanTerm(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.BooleanTermContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.BooleanTermContext,i)


        def AND(self, i:int=None):
            if i is None:
                return self.getTokens(RulesDSLParser.AND)
            else:
                return self.getToken(RulesDSLParser.AND, i)

        def OR(self, i:int=None):
            if i is None:
                return self.getTokens(RulesDSLParser.OR)
            else:
                return self.getToken(RulesDSLParser.OR, i)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_booleanExpr

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanExpr" ):
                return visitor.visitBooleanExpr(self)
            else:
                return visitor.visitChildren(self)




    def booleanExpr(self):

        localctx = RulesDSLParser.BooleanExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_booleanExpr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 580
            self.booleanTerm()
            self.state = 585
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==24 or _la==25:
                self.state = 581
                _la = self._input.LA(1)
                if not(_la==24 or _la==25):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 582
                self.booleanTerm()
                self.state = 587
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanTermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanFactor(self):
            return self.getTypedRuleContext(RulesDSLParser.BooleanFactorContext,0)


        def NOT(self):
            return self.getToken(RulesDSLParser.NOT, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_booleanTerm

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanTerm" ):
                return visitor.visitBooleanTerm(self)
            else:
                return visitor.visitChildren(self)




    def booleanTerm(self):

        localctx = RulesDSLParser.BooleanTermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_booleanTerm)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 589
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==26:
                self.state = 588
                self.match(RulesDSLParser.NOT)


            self.state = 591
            self.booleanFactor()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanFactorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def comparisonExpr(self):
            return self.getTypedRuleContext(RulesDSLParser.ComparisonExprContext,0)


        def LPAREN(self):
            return self.getToken(RulesDSLParser.LPAREN, 0)

        def booleanExpr(self):
            return self.getTypedRuleContext(RulesDSLParser.BooleanExprContext,0)


        def RPAREN(self):
            return self.getToken(RulesDSLParser.RPAREN, 0)

        def functionCall(self):
            return self.getTypedRuleContext(RulesDSLParser.FunctionCallContext,0)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_booleanFactor

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanFactor" ):
                return visitor.visitBooleanFactor(self)
            else:
                return visitor.visitChildren(self)




    def booleanFactor(self):

        localctx = RulesDSLParser.BooleanFactorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_booleanFactor)
        try:
            self.state = 599
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,50,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 593
                self.comparisonExpr()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 594
                self.match(RulesDSLParser.LPAREN)
                self.state = 595
                self.booleanExpr()
                self.state = 596
                self.match(RulesDSLParser.RPAREN)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 598
                self.functionCall()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def valueExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.ValueExprContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.ValueExprContext,i)


        def comparisonOp(self):
            return self.getTypedRuleContext(RulesDSLParser.ComparisonOpContext,0)


        def IN(self):
            return self.getToken(RulesDSLParser.IN, 0)

        def LPAREN(self):
            return self.getToken(RulesDSLParser.LPAREN, 0)

        def valueList(self):
            return self.getTypedRuleContext(RulesDSLParser.ValueListContext,0)


        def RPAREN(self):
            return self.getToken(RulesDSLParser.RPAREN, 0)

        def NOT(self):
            return self.getToken(RulesDSLParser.NOT, 0)

        def listLiteral(self):
            return self.getTypedRuleContext(RulesDSLParser.ListLiteralContext,0)


        def fieldPath(self):
            return self.getTypedRuleContext(RulesDSLParser.FieldPathContext,0)


        def IS(self):
            return self.getToken(RulesDSLParser.IS, 0)

        def NULL(self):
            return self.getToken(RulesDSLParser.NULL, 0)

        def IS_NULL(self):
            return self.getToken(RulesDSLParser.IS_NULL, 0)

        def IS_NOT_NULL(self):
            return self.getToken(RulesDSLParser.IS_NOT_NULL, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_comparisonExpr

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparisonExpr" ):
                return visitor.visitComparisonExpr(self)
            else:
                return visitor.visitChildren(self)




    def comparisonExpr(self):

        localctx = RulesDSLParser.ComparisonExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_comparisonExpr)
        try:
            self.state = 651
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,51,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 601
                self.valueExpr()
                self.state = 602
                self.comparisonOp()
                self.state = 603
                self.valueExpr()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 605
                self.valueExpr()
                self.state = 606
                self.match(RulesDSLParser.IN)
                self.state = 607
                self.match(RulesDSLParser.LPAREN)
                self.state = 608
                self.valueList()
                self.state = 609
                self.match(RulesDSLParser.RPAREN)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 611
                self.valueExpr()
                self.state = 612
                self.match(RulesDSLParser.NOT)
                self.state = 613
                self.match(RulesDSLParser.IN)
                self.state = 614
                self.match(RulesDSLParser.LPAREN)
                self.state = 615
                self.valueList()
                self.state = 616
                self.match(RulesDSLParser.RPAREN)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 618
                self.valueExpr()
                self.state = 619
                self.match(RulesDSLParser.IN)
                self.state = 620
                self.listLiteral()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 622
                self.valueExpr()
                self.state = 623
                self.match(RulesDSLParser.NOT)
                self.state = 624
                self.match(RulesDSLParser.IN)
                self.state = 625
                self.listLiteral()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 627
                self.valueExpr()
                self.state = 628
                self.match(RulesDSLParser.IN)
                self.state = 629
                self.fieldPath()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 631
                self.valueExpr()
                self.state = 632
                self.match(RulesDSLParser.NOT)
                self.state = 633
                self.match(RulesDSLParser.IN)
                self.state = 634
                self.fieldPath()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 636
                self.valueExpr()
                self.state = 637
                self.match(RulesDSLParser.IS)
                self.state = 638
                self.match(RulesDSLParser.NULL)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 640
                self.valueExpr()
                self.state = 641
                self.match(RulesDSLParser.IS)
                self.state = 642
                self.match(RulesDSLParser.NOT)
                self.state = 643
                self.match(RulesDSLParser.NULL)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 645
                self.valueExpr()
                self.state = 646
                self.match(RulesDSLParser.IS_NULL)
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 648
                self.valueExpr()
                self.state = 649
                self.match(RulesDSLParser.IS_NOT_NULL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQ(self):
            return self.getToken(RulesDSLParser.EQ, 0)

        def NE(self):
            return self.getToken(RulesDSLParser.NE, 0)

        def LT(self):
            return self.getToken(RulesDSLParser.LT, 0)

        def GT(self):
            return self.getToken(RulesDSLParser.GT, 0)

        def LE(self):
            return self.getToken(RulesDSLParser.LE, 0)

        def GE(self):
            return self.getToken(RulesDSLParser.GE, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_comparisonOp

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparisonOp" ):
                return visitor.visitComparisonOp(self)
            else:
                return visitor.visitChildren(self)




    def comparisonOp(self):

        localctx = RulesDSLParser.ComparisonOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_comparisonOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 653
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 567453553048682496) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValueExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.TermContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.TermContext,i)


        def PLUS(self, i:int=None):
            if i is None:
                return self.getTokens(RulesDSLParser.PLUS)
            else:
                return self.getToken(RulesDSLParser.PLUS, i)

        def MINUS(self, i:int=None):
            if i is None:
                return self.getTokens(RulesDSLParser.MINUS)
            else:
                return self.getToken(RulesDSLParser.MINUS, i)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_valueExpr

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValueExpr" ):
                return visitor.visitValueExpr(self)
            else:
                return visitor.visitChildren(self)




    def valueExpr(self):

        localctx = RulesDSLParser.ValueExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_valueExpr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 655
            self.term()
            self.state = 660
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,52,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 656
                    _la = self._input.LA(1)
                    if not(_la==59 or _la==60):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 657
                    self.term() 
                self.state = 662
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,52,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def factor(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.FactorContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.FactorContext,i)


        def STAR(self, i:int=None):
            if i is None:
                return self.getTokens(RulesDSLParser.STAR)
            else:
                return self.getToken(RulesDSLParser.STAR, i)

        def SLASH(self, i:int=None):
            if i is None:
                return self.getTokens(RulesDSLParser.SLASH)
            else:
                return self.getToken(RulesDSLParser.SLASH, i)

        def PERCENT(self, i:int=None):
            if i is None:
                return self.getTokens(RulesDSLParser.PERCENT)
            else:
                return self.getToken(RulesDSLParser.PERCENT, i)

        def MOD(self, i:int=None):
            if i is None:
                return self.getTokens(RulesDSLParser.MOD)
            else:
                return self.getToken(RulesDSLParser.MOD, i)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_term

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTerm" ):
                return visitor.visitTerm(self)
            else:
                return visitor.visitChildren(self)




    def term(self):

        localctx = RulesDSLParser.TermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_term)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 663
            self.factor()
            self.state = 668
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,53,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 664
                    _la = self._input.LA(1)
                    if not(((((_la - 61)) & ~0x3f) == 0 and ((1 << (_la - 61)) & 15) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 665
                    self.factor() 
                self.state = 670
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,53,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FactorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atom(self):
            return self.getTypedRuleContext(RulesDSLParser.AtomContext,0)


        def MINUS(self):
            return self.getToken(RulesDSLParser.MINUS, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_factor

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactor" ):
                return visitor.visitFactor(self)
            else:
                return visitor.visitChildren(self)




    def factor(self):

        localctx = RulesDSLParser.FactorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_factor)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 672
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,54,self._ctx)
            if la_ == 1:
                self.state = 671
                self.match(RulesDSLParser.MINUS)


            self.state = 674
            self.atom()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AtomContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def literal(self):
            return self.getTypedRuleContext(RulesDSLParser.LiteralContext,0)


        def fieldPath(self):
            return self.getTypedRuleContext(RulesDSLParser.FieldPathContext,0)


        def functionCall(self):
            return self.getTypedRuleContext(RulesDSLParser.FunctionCallContext,0)


        def listLiteral(self):
            return self.getTypedRuleContext(RulesDSLParser.ListLiteralContext,0)


        def objectLiteral(self):
            return self.getTypedRuleContext(RulesDSLParser.ObjectLiteralContext,0)


        def lambdaExpression(self):
            return self.getTypedRuleContext(RulesDSLParser.LambdaExpressionContext,0)


        def LPAREN(self):
            return self.getToken(RulesDSLParser.LPAREN, 0)

        def valueExpr(self):
            return self.getTypedRuleContext(RulesDSLParser.ValueExprContext,0)


        def RPAREN(self):
            return self.getToken(RulesDSLParser.RPAREN, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_atom

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtom" ):
                return visitor.visitAtom(self)
            else:
                return visitor.visitChildren(self)




    def atom(self):

        localctx = RulesDSLParser.AtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_atom)
        try:
            self.state = 686
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,55,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 676
                self.literal()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 677
                self.fieldPath()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 678
                self.functionCall()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 679
                self.listLiteral()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 680
                self.objectLiteral()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 681
                self.lambdaExpression()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 682
                self.match(RulesDSLParser.LPAREN)
                self.state = 683
                self.valueExpr()
                self.state = 684
                self.match(RulesDSLParser.RPAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LambdaExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(RulesDSLParser.IDENTIFIER)
            else:
                return self.getToken(RulesDSLParser.IDENTIFIER, i)

        def ARROW(self):
            return self.getToken(RulesDSLParser.ARROW, 0)

        def valueExpr(self):
            return self.getTypedRuleContext(RulesDSLParser.ValueExprContext,0)


        def LPAREN(self):
            return self.getToken(RulesDSLParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(RulesDSLParser.RPAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RulesDSLParser.COMMA)
            else:
                return self.getToken(RulesDSLParser.COMMA, i)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_lambdaExpression

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLambdaExpression" ):
                return visitor.visitLambdaExpression(self)
            else:
                return visitor.visitChildren(self)




    def lambdaExpression(self):

        localctx = RulesDSLParser.LambdaExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_lambdaExpression)
        self._la = 0 # Token type
        try:
            self.state = 703
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [86]:
                self.enterOuterAlt(localctx, 1)
                self.state = 688
                self.match(RulesDSLParser.IDENTIFIER)
                self.state = 689
                self.match(RulesDSLParser.ARROW)
                self.state = 690
                self.valueExpr()
                pass
            elif token in [70]:
                self.enterOuterAlt(localctx, 2)
                self.state = 691
                self.match(RulesDSLParser.LPAREN)
                self.state = 692
                self.match(RulesDSLParser.IDENTIFIER)
                self.state = 697
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==68:
                    self.state = 693
                    self.match(RulesDSLParser.COMMA)
                    self.state = 694
                    self.match(RulesDSLParser.IDENTIFIER)
                    self.state = 699
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 700
                self.match(RulesDSLParser.RPAREN)
                self.state = 701
                self.match(RulesDSLParser.ARROW)
                self.state = 702
                self.valueExpr()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArithmeticExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def valueExpr(self):
            return self.getTypedRuleContext(RulesDSLParser.ValueExprContext,0)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_arithmeticExpr

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArithmeticExpr" ):
                return visitor.visitArithmeticExpr(self)
            else:
                return visitor.visitChildren(self)




    def arithmeticExpr(self):

        localctx = RulesDSLParser.ArithmeticExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_arithmeticExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 705
            self.valueExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RulesDSLParser.IDENTIFIER, 0)

        def LPAREN(self):
            return self.getToken(RulesDSLParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(RulesDSLParser.RPAREN, 0)

        def valueExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.ValueExprContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.ValueExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RulesDSLParser.COMMA)
            else:
                return self.getToken(RulesDSLParser.COMMA, i)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_functionCall

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionCall" ):
                return visitor.visitFunctionCall(self)
            else:
                return visitor.visitChildren(self)




    def functionCall(self):

        localctx = RulesDSLParser.FunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_functionCall)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 707
            self.match(RulesDSLParser.IDENTIFIER)
            self.state = 708
            self.match(RulesDSLParser.LPAREN)
            self.state = 717
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 29)) & ~0x3f) == 0 and ((1 << (_la - 29)) & 215374538819502081) != 0):
                self.state = 709
                self.valueExpr()
                self.state = 714
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==68:
                    self.state = 710
                    self.match(RulesDSLParser.COMMA)
                    self.state = 711
                    self.valueExpr()
                    self.state = 716
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 719
            self.match(RulesDSLParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FieldPathContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def attributeIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.AttributeIdentifierContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.AttributeIdentifierContext,i)


        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(RulesDSLParser.DOT)
            else:
                return self.getToken(RulesDSLParser.DOT, i)

        def IDENTIFIER(self):
            return self.getToken(RulesDSLParser.IDENTIFIER, 0)

        def LBRACKET(self):
            return self.getToken(RulesDSLParser.LBRACKET, 0)

        def INTEGER(self):
            return self.getToken(RulesDSLParser.INTEGER, 0)

        def RBRACKET(self):
            return self.getToken(RulesDSLParser.RBRACKET, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_fieldPath

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFieldPath" ):
                return visitor.visitFieldPath(self)
            else:
                return visitor.visitChildren(self)




    def fieldPath(self):

        localctx = RulesDSLParser.FieldPathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_fieldPath)
        self._la = 0 # Token type
        try:
            self.state = 740
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,62,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 721
                self.attributeIdentifier()
                self.state = 726
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==69:
                    self.state = 722
                    self.match(RulesDSLParser.DOT)
                    self.state = 723
                    self.attributeIdentifier()
                    self.state = 728
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 729
                self.match(RulesDSLParser.IDENTIFIER)
                self.state = 730
                self.match(RulesDSLParser.LBRACKET)
                self.state = 731
                self.match(RulesDSLParser.INTEGER)
                self.state = 732
                self.match(RulesDSLParser.RBRACKET)
                self.state = 737
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==69:
                    self.state = 733
                    self.match(RulesDSLParser.DOT)
                    self.state = 734
                    self.attributeIdentifier()
                    self.state = 739
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AttributeIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RulesDSLParser.IDENTIFIER, 0)

        def DQUOTED_STRING(self):
            return self.getToken(RulesDSLParser.DQUOTED_STRING, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_attributeIdentifier

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttributeIdentifier" ):
                return visitor.visitAttributeIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def attributeIdentifier(self):

        localctx = RulesDSLParser.AttributeIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_attributeIdentifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 742
            _la = self._input.LA(1)
            if not(_la==83 or _la==86):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValueListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def valueExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.ValueExprContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.ValueExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RulesDSLParser.COMMA)
            else:
                return self.getToken(RulesDSLParser.COMMA, i)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_valueList

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValueList" ):
                return visitor.visitValueList(self)
            else:
                return visitor.visitChildren(self)




    def valueList(self):

        localctx = RulesDSLParser.ValueListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_valueList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 744
            self.valueExpr()
            self.state = 749
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==68:
                self.state = 745
                self.match(RulesDSLParser.COMMA)
                self.state = 746
                self.valueExpr()
                self.state = 751
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ListLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACKET(self):
            return self.getToken(RulesDSLParser.LBRACKET, 0)

        def RBRACKET(self):
            return self.getToken(RulesDSLParser.RBRACKET, 0)

        def valueExpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.ValueExprContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.ValueExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RulesDSLParser.COMMA)
            else:
                return self.getToken(RulesDSLParser.COMMA, i)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_listLiteral

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitListLiteral" ):
                return visitor.visitListLiteral(self)
            else:
                return visitor.visitChildren(self)




    def listLiteral(self):

        localctx = RulesDSLParser.ListLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_listLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 752
            self.match(RulesDSLParser.LBRACKET)
            self.state = 761
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 29)) & ~0x3f) == 0 and ((1 << (_la - 29)) & 215374538819502081) != 0):
                self.state = 753
                self.valueExpr()
                self.state = 758
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==68:
                    self.state = 754
                    self.match(RulesDSLParser.COMMA)
                    self.state = 755
                    self.valueExpr()
                    self.state = 760
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 763
            self.match(RulesDSLParser.RBRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBRACE(self):
            return self.getToken(RulesDSLParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(RulesDSLParser.RBRACE, 0)

        def objectField(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RulesDSLParser.ObjectFieldContext)
            else:
                return self.getTypedRuleContext(RulesDSLParser.ObjectFieldContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RulesDSLParser.COMMA)
            else:
                return self.getToken(RulesDSLParser.COMMA, i)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_objectLiteral

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectLiteral" ):
                return visitor.visitObjectLiteral(self)
            else:
                return visitor.visitChildren(self)




    def objectLiteral(self):

        localctx = RulesDSLParser.ObjectLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_objectLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 765
            self.match(RulesDSLParser.LBRACE)
            self.state = 774
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 847173709201472) != 0) or _la==83 or _la==86:
                self.state = 766
                self.objectField()
                self.state = 771
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==68:
                    self.state = 767
                    self.match(RulesDSLParser.COMMA)
                    self.state = 768
                    self.objectField()
                    self.state = 773
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 776
            self.match(RulesDSLParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectFieldContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def objectFieldName(self):
            return self.getTypedRuleContext(RulesDSLParser.ObjectFieldNameContext,0)


        def COLON(self):
            return self.getToken(RulesDSLParser.COLON, 0)

        def valueExpr(self):
            return self.getTypedRuleContext(RulesDSLParser.ValueExprContext,0)


        def getRuleIndex(self):
            return RulesDSLParser.RULE_objectField

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectField" ):
                return visitor.visitObjectField(self)
            else:
                return visitor.visitChildren(self)




    def objectField(self):

        localctx = RulesDSLParser.ObjectFieldContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_objectField)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 778
            self.objectFieldName()
            self.state = 779
            self.match(RulesDSLParser.COLON)
            self.state = 780
            self.valueExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectFieldNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RulesDSLParser.IDENTIFIER, 0)

        def DQUOTED_STRING(self):
            return self.getToken(RulesDSLParser.DQUOTED_STRING, 0)

        def TEXT_TYPE(self):
            return self.getToken(RulesDSLParser.TEXT_TYPE, 0)

        def DESCRIPTION(self):
            return self.getToken(RulesDSLParser.DESCRIPTION, 0)

        def PRIORITY(self):
            return self.getToken(RulesDSLParser.PRIORITY, 0)

        def RETURN(self):
            return self.getToken(RulesDSLParser.RETURN, 0)

        def DEFAULT(self):
            return self.getToken(RulesDSLParser.DEFAULT, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_objectFieldName

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitObjectFieldName" ):
                return visitor.visitObjectFieldName(self)
            else:
                return visitor.visitChildren(self)




    def objectFieldName(self):

        localctx = RulesDSLParser.ObjectFieldNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_objectFieldName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 782
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 847173709201472) != 0) or _la==83 or _la==86):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stringLiteral(self):
            return self.getTypedRuleContext(RulesDSLParser.StringLiteralContext,0)


        def numberLiteral(self):
            return self.getTypedRuleContext(RulesDSLParser.NumberLiteralContext,0)


        def MONEY_LITERAL(self):
            return self.getToken(RulesDSLParser.MONEY_LITERAL, 0)

        def PERCENTAGE_LITERAL(self):
            return self.getToken(RulesDSLParser.PERCENTAGE_LITERAL, 0)

        def BOOLEAN(self):
            return self.getToken(RulesDSLParser.BOOLEAN, 0)

        def NULL(self):
            return self.getToken(RulesDSLParser.NULL, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_literal

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteral" ):
                return visitor.visitLiteral(self)
            else:
                return visitor.visitChildren(self)




    def literal(self):

        localctx = RulesDSLParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_literal)
        try:
            self.state = 790
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [83, 84]:
                self.enterOuterAlt(localctx, 1)
                self.state = 784
                self.stringLiteral()
                pass
            elif token in [60, 79, 80]:
                self.enterOuterAlt(localctx, 2)
                self.state = 785
                self.numberLiteral()
                pass
            elif token in [81]:
                self.enterOuterAlt(localctx, 3)
                self.state = 786
                self.match(RulesDSLParser.MONEY_LITERAL)
                pass
            elif token in [82]:
                self.enterOuterAlt(localctx, 4)
                self.state = 787
                self.match(RulesDSLParser.PERCENTAGE_LITERAL)
                pass
            elif token in [77]:
                self.enterOuterAlt(localctx, 5)
                self.state = 788
                self.match(RulesDSLParser.BOOLEAN)
                pass
            elif token in [29]:
                self.enterOuterAlt(localctx, 6)
                self.state = 789
                self.match(RulesDSLParser.NULL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER(self):
            return self.getToken(RulesDSLParser.INTEGER, 0)

        def DECIMAL(self):
            return self.getToken(RulesDSLParser.DECIMAL, 0)

        def MINUS(self):
            return self.getToken(RulesDSLParser.MINUS, 0)

        def getRuleIndex(self):
            return RulesDSLParser.RULE_numberLiteral

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumberLiteral" ):
                return visitor.visitNumberLiteral(self)
            else:
                return visitor.visitChildren(self)




    def numberLiteral(self):

        localctx = RulesDSLParser.NumberLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_numberLiteral)
        try:
            self.state = 798
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,69,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 792
                self.match(RulesDSLParser.INTEGER)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 793
                self.match(RulesDSLParser.DECIMAL)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 794
                self.match(RulesDSLParser.MINUS)
                self.state = 795
                self.match(RulesDSLParser.INTEGER)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 796
                self.match(RulesDSLParser.MINUS)
                self.state = 797
                self.match(RulesDSLParser.DECIMAL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





