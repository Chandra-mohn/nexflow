/**
 * EnrichTransactionProcessFunction
 *
 * ProcessFunction for enrich_transaction
 *
 * AUTO-GENERATED by Nexflow Code Generator
 * DO NOT EDIT - Changes will be overwritten
 *
 * Generator: TransformGenerator
 */

package nexflow.flink.transform;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;

import org.apache.flink.configuration.Configuration;
import org.apache.flink.streaming.api.functions.KeyedProcessFunction;
import org.apache.flink.util.Collector;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class EnrichTransactionProcessFunction
        extends KeyedProcessFunction<String, EnrichTransactionInput, Object> {

    private static final Logger LOG = LoggerFactory.getLogger(EnrichTransactionProcessFunction.class);

    // Referenced transforms
    private transient NormalizeCurrencyFunction normalizeCurrencyTransform;
    private transient CalculateRiskScoreFunction calculateRiskScoreTransform;

    @Override
    public void open(Configuration parameters) throws Exception {
        normalizeCurrencyTransform = new NormalizeCurrencyFunction();
        calculateRiskScoreTransform = new CalculateRiskScoreFunction();
    }

    @Override
    public void processElement(EnrichTransactionInput value, Context ctx,
            Collector<Object> out) throws Exception {
        try {
            Object result = transform(value);
            out.collect(result);
        } catch (Exception e) {
            handleError(e, value);
        }
    }

    /**
     * Transform Block: enrich_transaction
     * Enriches transaction with risk analysis
     */
    public Object transform(EnrichTransactionInput input) throws Exception {
        validateInput(input);

        Object result = new Object();

        // Apply field mappings
        result.getEnriched().setTransactionId(input.getTransaction().getTransactionId());
        result.getEnriched().setCustomerId(input.getTransaction().getCustomerId());
        result.getEnriched().setAmount(input.getTransaction().getAmount());
        result.getEnriched().setNormalizedAmount(normalizeCurrency(input.getTransaction().getAmount(), (input.getTransaction().getCurrency() != null ? input.getTransaction().getCurrency() : "USD")));
        result.getEnriched().setMerchantId(input.getTransaction().getMerchantId());
        result.getEnriched().setRiskTier(input.getCustomer().getRiskTier());
        result.getEnriched().setCreditLimit(input.getCustomer().getCreditLimit());
        result.getEnriched().setAccountAge(input.getCustomer().getAccountAgeDays());
        result.getEnriched().setVelocity24h(input.getCustomer().getTransactionCount24h());
        result.getEnriched().setFraudProbability(calculateRiskScore(input.getTransaction().getAmount(), input.getCustomer().getTransactionCount24h(), input.getCustomer().getAccountAgeDays(), input.getCustomer().getRiskTier()));
        result.getEnriched().setEventTimestamp(input.getTransaction().getEventTimestamp());
        result.getEnriched().setProcessingTimestamp(Instant.now());

        checkInvariants(result);

        validateOutput(result);

        return result;
    }

    /**
     * Validates input data before transformation.
     */
    private void validateInput(Object input) throws ValidationException {
        List<String> errors = new ArrayList<>();

        // Validation: Invalid transaction amount
        if (!((input.getTransaction().getAmount() > 0L))) {
            errors.add("Invalid transaction amount");
        }
        // Validation: Customer ID mismatch
        if (!((input.getCustomer().getCustomerId() == input.getTransaction().getCustomerId()))) {
            errors.add("Customer ID mismatch");
        }

        if (!errors.isEmpty()) {
            throw new ValidationException("Input validation failed", errors);
        }
    }

    /**
     * Validates output data after transformation.
     */
    private void validateOutput(Object output) throws ValidationException {
        List<String> errors = new ArrayList<>();

        // Validation: Invalid probability
        if (!(((output.getEnriched().getFraudProbability() >= new BigDecimal("0.0")) && (output.getEnriched().getFraudProbability() <= new BigDecimal("1.0"))))) {
            errors.add("Invalid probability");
        }

        if (!errors.isEmpty()) {
            throw new ValidationException("Output validation failed", errors);
        }
    }

    /**
     * Checks invariant conditions.
     */
    private void checkInvariants(Object result) throws InvariantViolationException {
        List<String> violations = new ArrayList<>();

        // Invariant: Normalized amount invariant violated
        if (!((result.getEnriched().getNormalizedAmount() > 0L))) {
            violations.add("Normalized amount invariant violated");
        }

        if (!violations.isEmpty()) {
            throw new InvariantViolationException("Invariant violated", violations);
        }
    }

    /**
     * Exception thrown when validation fails.
     */
    public static class ValidationException extends Exception {
        private final List<String> errors;

        public ValidationException(String message, List<String> errors) {
            super(message + ": " + String.join(", ", errors));
            this.errors = errors;
        }

        public List<String> getErrors() {
            return errors;
        }
    }
    /**
     * Exception thrown when invariant is violated.
     */
    public static class InvariantViolationException extends Exception {
        private final List<String> violations;

        public InvariantViolationException(String message, List<String> violations) {
            super(message + ": " + String.join(", ", violations));
            this.violations = violations;
        }

        public List<String> getViolations() {
            return violations;
        }
    }

    /**
     * Error handler for enrich_transaction
     */
    private Object handleError(Exception e, Object input) {
        LOG.warn("Transform error: {}", e.getMessage());
        // Emit error to transform_errors
        ErrorRecord errorRecord = new ErrorRecord();
        errorRecord.setOriginalRecord(input);
        errorRecord.setErrorMessage(e.getMessage());
        errorRecord.setErrorCode("TRANSFORM_ERROR");
        errorRecord.setTimestamp(Instant.now());
        emitToSideOutput("transform_errors", errorRecord);
        return null;
    }
    /**
     * Error record for side output emission.
     */
    public static class ErrorRecord {
        private Object originalRecord;
        private String errorMessage;
        private String errorCode;
        private Instant timestamp;

        public Object getOriginalRecord() { return originalRecord; }
        public void setOriginalRecord(Object originalRecord) {
            this.originalRecord = originalRecord;
        }

        public String getErrorMessage() { return errorMessage; }
        public void setErrorMessage(String errorMessage) {
            this.errorMessage = errorMessage;
        }

        public String getErrorCode() { return errorCode; }
        public void setErrorCode(String errorCode) {
            this.errorCode = errorCode;
        }

        public Instant getTimestamp() { return timestamp; }
        public void setTimestamp(Instant timestamp) {
            this.timestamp = timestamp;
        }
    }
    /**
     * Exception thrown when a record should be rejected.
     */
    public static class TransformRejectedException extends RuntimeException {
        public TransformRejectedException(Throwable cause) {
            super("Record rejected during transform", cause);
        }
    }

    /**
     * General transform exception.
     */
    public static class TransformException extends RuntimeException {
        public TransformException(String message, Throwable cause) {
            super(message, cause);
        }
    }

    /**
     * Recalculate on change of: transaction.amount, customer.risk_tier
     */
    private static final Set<String> WATCHED_FIELDS = Set.of("transaction.amount", "customer.risk_tier");

    private boolean shouldRecalculate(Set<String> changedFields) {
        return !Collections.disjoint(WATCHED_FIELDS, changedFields);
    }

    private void recalculate(Object input) {
        input.getEnriched().setNormalizedAmount(normalizeCurrency(input.getTransaction().getAmount(), (input.getTransaction().getCurrency() != null ? input.getTransaction().getCurrency() : "USD")));
        input.getEnriched().setFraudProbability(calculateRiskScore(input.getTransaction().getAmount(), input.getCustomer().getTransactionCount24h(), input.getCustomer().getAccountAgeDays(), input.getCustomer().getRiskTier()));
    }

}