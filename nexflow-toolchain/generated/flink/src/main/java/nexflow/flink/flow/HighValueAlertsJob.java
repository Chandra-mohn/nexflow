/**
 * HighValueAlertsJob
 *
 * Flink Streaming Job for process: high_value_alerts
 *
 * AUTO-GENERATED by Nexflow Code Generator
 * DO NOT EDIT - Changes will be overwritten
 */
package nexflow.flink.flow;

import java.time.Duration;
import org.apache.flink.api.common.eventtime.WatermarkStrategy;
import org.apache.flink.connector.base.DeliveryGuarantee;
import org.apache.flink.connector.kafka.sink.KafkaRecordSerializationSchema;
import org.apache.flink.connector.kafka.sink.KafkaSink;
import org.apache.flink.connector.kafka.source.KafkaSource;
import org.apache.flink.connector.kafka.source.enumerator.initializer.OffsetsInitializer;
import org.apache.flink.streaming.api.CheckpointingMode;
import org.apache.flink.streaming.api.datastream.DataStream;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.kafka.clients.consumer.OffsetResetStrategy;

public class HighValueAlertsJob {

    // Job Configuration
    private static final String JOB_NAME = "high_value_alerts";
    private static final int DEFAULT_PARALLELISM = 4;
    private static final String KAFKA_BOOTSTRAP_SERVERS = 
        System.getenv().getOrDefault("KAFKA_BOOTSTRAP_SERVERS", "localhost:9092");

    public static void main(String[] args) throws Exception {
        // Create execution environment
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(DEFAULT_PARALLELISM);

        // Build and execute pipeline
        HighValueAlertsJob job = new HighValueAlertsJob();
        job.buildPipeline(env);

        // Execute
        env.execute(JOB_NAME);
    }

    /**
     * Build the streaming pipeline.
     */
    public void buildPipeline(StreamExecutionEnvironment env) {

        // Source: fraud_alerts
        KafkaSource<FraudAlert> fraud_alertsSource = KafkaSource
            .<FraudAlert>builder()
            .setBootstrapServers(KAFKA_BOOTSTRAP_SERVERS)
            .setTopics("fraud_alerts")
            .setGroupId("high_value_alerts-consumer")
            .setStartingOffsets(OffsetsInitializer.committedOffsets(OffsetResetStrategy.EARLIEST))
            .build();

        DataStream<FraudAlert> fraudAlertsStream = env
            .fromSource(
                fraud_alertsSource,
                WatermarkStrategy.<FraudAlert>forBoundedOutOfOrderness(Duration.ofMillis(5000)),
                "fraud_alerts"
            );

        // Processing Pipeline
        // TODO: Wire up processing operators

        // Sinks
        // - emit to escalated_alerts
    }

}