/**
 * FraudDetectionProcessFunction
 *
 * ProcessFunction for fraud_detection
 *
 * AUTO-GENERATED by Nexflow Code Generator
 * DO NOT EDIT - Changes will be overwritten
 *
 * Generator: FlowGenerator
 */

package nexflow.flink.flow;

import org.apache.flink.api.common.state.ListState;
import org.apache.flink.api.common.state.ListStateDescriptor;
import org.apache.flink.api.common.state.StateTtlConfig;
import org.apache.flink.api.common.state.StateTtlConfig.StateVisibility;
import org.apache.flink.api.common.state.StateTtlConfig.UpdateType;
import org.apache.flink.api.common.state.ValueState;
import org.apache.flink.api.common.state.ValueStateDescriptor;
import org.apache.flink.api.common.time.Time;
import org.apache.flink.configuration.Configuration;
import org.apache.flink.streaming.api.CheckpointingMode;
import org.apache.flink.streaming.api.environment.CheckpointConfig;
import org.apache.flink.streaming.api.functions.KeyedProcessFunction;
import org.apache.flink.util.Collector;
import org.apache.flink.util.OutputTag;

import nexflow.flink.schema.EnrichedTransaction;
import nexflow.flink.schema.Transaction;


public class FraudDetectionProcessFunction
        extends KeyedProcessFunction<String, Transaction, EnrichedTransaction> {

// State Descriptors
// Local state: velocity_counter
private transient ValueState<Long> velocityCounterState;

// State initialization (add to open() method)
@Override
public void open(Configuration parameters) throws Exception {
    // velocity_counter: counter
    ValueStateDescriptor<Long> velocityCounterStateDesc = new ValueStateDescriptor<>("velocity_counter", Long.class);
    StateTtlConfig ttlConfig = StateTtlConfig
        .newBuilder(Time.milliseconds(86400000))
        .setUpdateType(UpdateType.OnCreateAndWrite)
        .setStateVisibility(StateVisibility.NeverReturnExpired)
        .build();
    velocityCounterStateDesc.enableTimeToLive(ttlConfig);
    velocityCounterState = getRuntimeContext().getState(velocityCounterStateDesc);

}

    @Override
    public void processElement(Transaction value, Context ctx, Collector<EnrichedTransaction> out)
            throws Exception {
        try {
            // Process the record
            // Enrich from: customer_lookup
            // Apply transform: normalize_amount
            // Route using: fraud_rules
            
            // Emit result
            out.collect(result);
        } catch (Exception e) {
            // Error handling
            handleError(e, value, ctx);
        }
    }

}