/**
 * FraudDetectionProcessFunction
 *
 * ProcessFunction for fraud_detection
 *
 * AUTO-GENERATED by Nexflow Code Generator
 * DO NOT EDIT - Changes will be overwritten
 *
 * Generator: FlowGenerator
 */

package nexflow.flink.flow;

import java.util.HashMap;
import java.util.Map;

import org.apache.flink.api.common.state.ListState;
import org.apache.flink.api.common.state.ListStateDescriptor;
import org.apache.flink.api.common.state.StateTtlConfig;
import org.apache.flink.api.common.state.StateTtlConfig.StateVisibility;
import org.apache.flink.api.common.state.StateTtlConfig.UpdateType;
import org.apache.flink.api.common.state.ValueState;
import org.apache.flink.api.common.state.ValueStateDescriptor;
import org.apache.flink.api.common.time.Time;
import org.apache.flink.configuration.Configuration;
import org.apache.flink.streaming.api.CheckpointingMode;
import org.apache.flink.streaming.api.environment.CheckpointConfig;
import org.apache.flink.streaming.api.functions.KeyedProcessFunction;
import org.apache.flink.util.Collector;
import org.apache.flink.util.OutputTag;

import nexflow.flink.schema.EnrichedTransaction;
import nexflow.flink.schema.Transaction;


public class FraudDetectionProcessFunction
        extends KeyedProcessFunction<String, Transaction, EnrichedTransaction> {

    private static final long serialVersionUID = 1L;

// State Descriptors
// Local state: velocity_counter
private transient ValueState<Long> velocityCounterState;

// State initialization (add to open() method)
@Override
public void open(Configuration parameters) throws Exception {
    // velocity_counter: counter
    ValueStateDescriptor<Long> velocityCounterStateDesc = new ValueStateDescriptor<>("velocity_counter", Long.class);
    StateTtlConfig ttlConfig = StateTtlConfig
        .newBuilder(Time.milliseconds(86400000))
        .setUpdateType(UpdateType.OnCreateAndWrite)
        .setStateVisibility(StateVisibility.NeverReturnExpired)
        .build();
    velocityCounterStateDesc.enableTimeToLive(ttlConfig);
    velocityCounterState = getRuntimeContext().getState(velocityCounterStateDesc);

}

    @Override
    public void processElement(Transaction value, Context ctx, Collector<EnrichedTransaction> out)
            throws Exception {
        try {
            // Process the record through the pipeline

            // Enrich from: customer_lookup
            // Note: In ProcessFunction context, enrichment is synchronous
            EnrichedTransaction enriched1 = enrichSync(value);

            // Apply transform: normalize_amount
            Map<String, Object> transformed2 = transform(enriched1);

            // Route using: fraud_rules
            String routeDecision = evaluateRoute(transformed2);
            // Side outputs available for different routing decisions

            // Create and emit result
            EnrichedTransaction result = enrichSync(value);
            out.collect(result);

        } catch (Exception e) {
            // Error handling based on resilience config
            handleError(e, value, ctx);
        }
    }

    /**
     * Synchronous enrichment helper for ProcessFunction context.
     * In async context, use AsyncDataStream.unorderedWait() instead.
     */
    private EnrichedTransaction enrichSync(Transaction input) {
        // TODO: Implement actual enrichment lookup
        // This is a scaffold - replace with real lookup logic
        EnrichedTransaction enriched = new EnrichedTransaction();
        // Copy base fields from input to enriched (generated by L2/L3)
        // Add enrichment data from lookup service
        return enriched;
    }

    /**
     * Transform helper for applying field transformations.
     */
    private Map<String, Object> transform(Object input) {
        Map<String, Object> result = new HashMap<>();
        result.put("_original", input);
        // TODO: Apply actual transformations from L3 transform definition
        return result;
    }

    /**
     * Route evaluation helper for determining routing decision.
     */
    private String evaluateRoute(Object input) {
        // TODO: Implement actual routing rules from L4 definition
        // Returns routing decision: "approve", "flag", "block", etc.
        return "approve";
    }

    /**
     * Error handling based on resilience configuration.
     */
    private void handleError(Exception e, Transaction value, Context ctx) {
        // Error handling strategies:
        // transform_failure: dead_letter
        // lookup_failure: retry
        // rule_failure: skip

        // Log error and decide action based on exception type
        String errorType = e.getClass().getSimpleName();

        // Default: log and continue (skip the record)
        System.err.println("Error processing record: " + errorType + " - " + e.getMessage());
        // For production, emit to dead letter queue or side output
    }

}