/**
 * Transaction
 *
 * Record for transaction schema
 *
 * AUTO-GENERATED by Nexflow Code Generator
 * DO NOT EDIT - Changes will be overwritten
 *
 * Generator: SchemaGenerator
 */

package nexflow.flink.schema;

import java.io.Serializable;
import java.math.BigDecimal;
import java.time.Instant;
import java.util.Objects;
import java.util.UUID;


public record Transaction(
    // Required
    UUID transactionId,
    // Required
    String customerId,
    // Required
    BigDecimal amount,
    // Required
    String currency,
    // Required
    String merchantId,
    String merchantName,
    String category,
    // Required
    Instant eventTimestamp,
    Instant processingTimestamp,
    String status,
    BigDecimal riskScore,
    String ipAddress,
    String deviceFingerprint
) implements Serializable {

    private static final long serialVersionUID = 1L;

    // =========================================================================
    // Schema Version Metadata
    // =========================================================================

    public static final String SCHEMA_VERSION = "2.0.0";
    public static final String SCHEMA_NAME = "transaction";

    // =========================================================================
    // Streaming Configuration Constants
    // =========================================================================

    public static final long IDLE_TIMEOUT_MS = 60000L;
    public static final String IDLE_BEHAVIOR = "MARK_IDLE";
    public static final long WATERMARK_DELAY_MS = 5000L;
    public static final String WATERMARK_STRATEGY = "BOUNDED_OUT_OF_ORDERNESS";
    public static final long ALLOWED_LATENESS_MS = 10000L;
    public static final String LATE_DATA_HANDLING = "SIDE_OUTPUT";
    public static final String LATE_DATA_STREAM = "late_transactions";
    public static final String TIME_SEMANTICS = "EVENT_TIME";
    public static final String TIME_FIELD = "event_timestamp";
    public static final String[] KEY_FIELDS = {"transaction_id"};

    // =========================================================================
    // Retention Configuration
    // =========================================================================

    public static final long RETENTION_MS = 7776000000L;

    /**
     * Compact constructor - validates required fields.
     */
    public Transaction {
        Objects.requireNonNull(transactionId, "transaction_id is required");
        Objects.requireNonNull(customerId, "customer_id is required");
        Objects.requireNonNull(amount, "amount is required");
        Objects.requireNonNull(currency, "currency is required");
        Objects.requireNonNull(merchantId, "merchant_id is required");
        Objects.requireNonNull(eventTimestamp, "event_timestamp is required");
    }

    /**
     * Create a copy with modified transactionId.
     * @param transactionId The new value
     * @return New record instance with updated value
     */
    public Transaction withTransactionId(UUID transactionId) {
        return new Transaction(transactionId, customerId(), amount(), currency(), merchantId(), merchantName(), category(), eventTimestamp(), processingTimestamp(), status(), riskScore(), ipAddress(), deviceFingerprint());
    }

    /**
     * Create a copy with modified customerId.
     * @param customerId The new value
     * @return New record instance with updated value
     */
    public Transaction withCustomerId(String customerId) {
        return new Transaction(transactionId(), customerId, amount(), currency(), merchantId(), merchantName(), category(), eventTimestamp(), processingTimestamp(), status(), riskScore(), ipAddress(), deviceFingerprint());
    }

    /**
     * Create a copy with modified amount.
     * @param amount The new value
     * @return New record instance with updated value
     */
    public Transaction withAmount(BigDecimal amount) {
        return new Transaction(transactionId(), customerId(), amount, currency(), merchantId(), merchantName(), category(), eventTimestamp(), processingTimestamp(), status(), riskScore(), ipAddress(), deviceFingerprint());
    }

    /**
     * Create a copy with modified currency.
     * @param currency The new value
     * @return New record instance with updated value
     */
    public Transaction withCurrency(String currency) {
        return new Transaction(transactionId(), customerId(), amount(), currency, merchantId(), merchantName(), category(), eventTimestamp(), processingTimestamp(), status(), riskScore(), ipAddress(), deviceFingerprint());
    }

    /**
     * Create a copy with modified merchantId.
     * @param merchantId The new value
     * @return New record instance with updated value
     */
    public Transaction withMerchantId(String merchantId) {
        return new Transaction(transactionId(), customerId(), amount(), currency(), merchantId, merchantName(), category(), eventTimestamp(), processingTimestamp(), status(), riskScore(), ipAddress(), deviceFingerprint());
    }

    /**
     * Create a copy with modified merchantName.
     * @param merchantName The new value
     * @return New record instance with updated value
     */
    public Transaction withMerchantName(String merchantName) {
        return new Transaction(transactionId(), customerId(), amount(), currency(), merchantId(), merchantName, category(), eventTimestamp(), processingTimestamp(), status(), riskScore(), ipAddress(), deviceFingerprint());
    }

    /**
     * Create a copy with modified category.
     * @param category The new value
     * @return New record instance with updated value
     */
    public Transaction withCategory(String category) {
        return new Transaction(transactionId(), customerId(), amount(), currency(), merchantId(), merchantName(), category, eventTimestamp(), processingTimestamp(), status(), riskScore(), ipAddress(), deviceFingerprint());
    }

    /**
     * Create a copy with modified eventTimestamp.
     * @param eventTimestamp The new value
     * @return New record instance with updated value
     */
    public Transaction withEventTimestamp(Instant eventTimestamp) {
        return new Transaction(transactionId(), customerId(), amount(), currency(), merchantId(), merchantName(), category(), eventTimestamp, processingTimestamp(), status(), riskScore(), ipAddress(), deviceFingerprint());
    }

    /**
     * Create a copy with modified processingTimestamp.
     * @param processingTimestamp The new value
     * @return New record instance with updated value
     */
    public Transaction withProcessingTimestamp(Instant processingTimestamp) {
        return new Transaction(transactionId(), customerId(), amount(), currency(), merchantId(), merchantName(), category(), eventTimestamp(), processingTimestamp, status(), riskScore(), ipAddress(), deviceFingerprint());
    }

    /**
     * Create a copy with modified status.
     * @param status The new value
     * @return New record instance with updated value
     */
    public Transaction withStatus(String status) {
        return new Transaction(transactionId(), customerId(), amount(), currency(), merchantId(), merchantName(), category(), eventTimestamp(), processingTimestamp(), status, riskScore(), ipAddress(), deviceFingerprint());
    }

    /**
     * Create a copy with modified riskScore.
     * @param riskScore The new value
     * @return New record instance with updated value
     */
    public Transaction withRiskScore(BigDecimal riskScore) {
        return new Transaction(transactionId(), customerId(), amount(), currency(), merchantId(), merchantName(), category(), eventTimestamp(), processingTimestamp(), status(), riskScore, ipAddress(), deviceFingerprint());
    }

    /**
     * Create a copy with modified ipAddress.
     * @param ipAddress The new value
     * @return New record instance with updated value
     */
    public Transaction withIpAddress(String ipAddress) {
        return new Transaction(transactionId(), customerId(), amount(), currency(), merchantId(), merchantName(), category(), eventTimestamp(), processingTimestamp(), status(), riskScore(), ipAddress, deviceFingerprint());
    }

    /**
     * Create a copy with modified deviceFingerprint.
     * @param deviceFingerprint The new value
     * @return New record instance with updated value
     */
    public Transaction withDeviceFingerprint(String deviceFingerprint) {
        return new Transaction(transactionId(), customerId(), amount(), currency(), merchantId(), merchantName(), category(), eventTimestamp(), processingTimestamp(), status(), riskScore(), ipAddress(), deviceFingerprint);
    }

    /**
     * Generate correlation key from specified fields.
     * Used by Flink keying operations for event correlation.
     *
     * @param fields Array of field names to include in the key
     * @return Concatenated string key from field values
     */
    public String getCorrelationKey(String[] fields) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < fields.length; i++) {
            if (i > 0) sb.append(":");
            switch (fields[i]) {
                case "transaction_id":
                    sb.append(transactionId());
                    break;
                case "customer_id":
                    sb.append(customerId());
                    break;
                case "amount":
                    sb.append(amount());
                    break;
                case "currency":
                    sb.append(currency());
                    break;
                case "merchant_id":
                    sb.append(merchantId());
                    break;
                case "merchant_name":
                    sb.append(merchantName());
                    break;
                case "category":
                    sb.append(category());
                    break;
                case "event_timestamp":
                    sb.append(eventTimestamp());
                    break;
                case "processing_timestamp":
                    sb.append(processingTimestamp());
                    break;
                case "status":
                    sb.append(status());
                    break;
                case "risk_score":
                    sb.append(riskScore());
                    break;
                case "ip_address":
                    sb.append(ipAddress());
                    break;
                case "device_fingerprint":
                    sb.append(deviceFingerprint());
                    break;
                default:
                    sb.append("null");
            }
        }
        return sb.toString();
    }

    /**
     * Alias for getCorrelationKey - used by hold patterns for buffer keying.
     */
    public String getBufferKey(String[] fields) {
        return getCorrelationKey(fields);
    }

    /**
     * Get simple key for this record (first identity field or fallback).
     * Used by window operations and RoutedEvent compatibility.
     */
    public String getKey() {
        // Return first non-null identity field as default key
        Object val = transactionId();
        return val != null ? val.toString() : "null";
    }

    /**
     * Get the timestamp value for event time processing.
     * Configured time field: event_timestamp
     */
    public long getEventTimestamp() {
        Object ts = eventTimestamp();
        if (ts == null) return System.currentTimeMillis();
        if (ts instanceof Long) return (Long) ts;
        if (ts instanceof java.time.Instant) return ((java.time.Instant) ts).toEpochMilli();
        if (ts instanceof java.util.Date) return ((java.util.Date) ts).getTime();
        return System.currentTimeMillis();
    }

    /**
     * Check if this record's source should be considered idle.
     * @param lastEventTime Last event timestamp in milliseconds
     * @param currentTime Current processing time in milliseconds
     */
    public static boolean isSourceIdle(long lastEventTime, long currentTime) {
        return (currentTime - lastEventTime) > IDLE_TIMEOUT_MS;
    }

    /**
     * Check if this record would be considered late.
     * @param eventTime Event timestamp in milliseconds
     * @param watermark Current watermark in milliseconds
     */
    public static boolean isLate(long eventTime, long watermark) {
        return eventTime < (watermark - ALLOWED_LATENESS_MS);
    }


}
