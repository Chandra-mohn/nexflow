/**
 * NormalizeCurrencyFunction
 *
 * MapFunction for normalize_currency
 *
 * AUTO-GENERATED by Nexflow Code Generator
 * DO NOT EDIT - Changes will be overwritten
 *
 * Generator: TransformGenerator
 */

package nexflow.flink.transform;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

import org.apache.flink.api.common.functions.RichMapFunction;
import org.apache.flink.api.common.state.MapState;
import org.apache.flink.api.common.state.MapStateDescriptor;
import org.apache.flink.api.common.state.StateTtlConfig;
import org.apache.flink.api.common.state.ValueState;
import org.apache.flink.api.common.state.ValueStateDescriptor;
import org.apache.flink.api.common.time.Time;
import org.apache.flink.configuration.Configuration;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class NormalizeCurrencyFunction extends RichMapFunction<Map<String, Object>, Map<String, Object>> {

    private static final Logger LOG = LoggerFactory.getLogger(NormalizeCurrencyFunction.class);
    // Pure function - no side effects

    // Flink State-based Cache Configuration (Key-based with TTL)
    private transient MapState<String, Object> normalizeCurrencyCacheMap;

    @Override
    public void open(Configuration parameters) throws Exception {
        super.open(parameters);

        // Configure state TTL for cache expiration
        StateTtlConfig ttlConfig = StateTtlConfig
            .newBuilder(Time.milliseconds(3600000L))
            .setUpdateType(StateTtlConfig.UpdateType.OnCreateAndWrite)
            .setStateVisibility(StateTtlConfig.StateVisibility.NeverReturnExpired)
            .build();

        MapStateDescriptor<String, Object> normalizeCurrencyCacheMapDesc =
            new MapStateDescriptor<>("normalize_currency_cache", String.class, Object.class);
        normalizeCurrencyCacheMapDesc.enableTimeToLive(ttlConfig);
        normalizeCurrencyCacheMap = getRuntimeContext().getMapState(normalizeCurrencyCacheMapDesc);
    }

    /**
     * Build cache key from currency
     */
    private String buildNormalizeCurrencyCacheKey(Map<String, Object> input) {
        StringBuilder keyBuilder = new StringBuilder();
        keyBuilder.append(String.valueOf(input.get("currency")));
        return keyBuilder.toString();
    }


    @Override
    public Map<String, Object> map(Map<String, Object> input) throws Exception {
        return transformWithCache(input);
    }

    /**
     * Transform: normalize_currency
     * Normalizes currency amounts to USD
     */
    public Map<String, Object> transform(Map<String, Object> input) throws Exception {
        validateInput(input);

        Map<String, Object> result = new HashMap<>();

        // Apply transformation logic
        result.put("rate", getExchangeRate(input.get("currency"), "USD"));
        result.put("normalized_amount", (((Number)input.get("amount")).doubleValue() * ((Number)result.get("rate")).doubleValue()));

        validateOutput(result);

        return result;
    }

    /**
     * Validates input data before transformation.
     */
    private void validateInput(Map<String, Object> input) throws ValidationException {
        List<String> errors = new ArrayList<>();

        // Validation: Amount must be positive
        if (!((((Number)input.get("amount")).doubleValue() > 0d))) {
            errors.add("Amount must be positive");
        }
        // Validation: Unsupported currency
        if (!(Arrays.asList("USD", "EUR", "GBP", "JPY", "CAD").contains(input.get("currency")))) {
            errors.add("Unsupported currency");
        }

        if (!errors.isEmpty()) {
            throw new ValidationException("Input validation failed", errors);
        }
    }

    /**
     * Validates output data after transformation.
     */
    private void validateOutput(Map<String, Object> output) throws ValidationException {
        List<String> errors = new ArrayList<>();

        // Validation: Normalized amount must be positive
        if (!((((Number)output.get("normalized_amount")).doubleValue() > 0d))) {
            errors.add("Normalized amount must be positive");
        }

        if (!errors.isEmpty()) {
            throw new ValidationException("Output validation failed", errors);
        }
    }

    /**
     * Exception thrown when validation fails.
     * Supports both simple string errors and structured ValidationError objects.
     */
    public static class ValidationException extends Exception {
        private final List<?> errors;

        public ValidationException(String message, List<?> errors) {
            super(message + ": " + formatErrors(errors));
            this.errors = errors;
        }

        @SuppressWarnings("unchecked")
        public <T> List<T> getErrors() {
            return (List<T>) errors;
        }

        /**
         * Get errors as strings (works for both String and ValidationError lists).
         */
        public List<String> getErrorMessages() {
            return errors.stream()
                .map(Object::toString)
                .collect(java.util.stream.Collectors.toList());
        }

        /**
         * Get errors filtered by severity (only for structured ValidationError lists).
         */
        public List<ValidationError> getErrorsBySeverity(ValidationSeverity severity) {
            return errors.stream()
                .filter(e -> e instanceof ValidationError)
                .map(e -> (ValidationError) e)
                .filter(e -> e.getSeverity() == severity)
                .collect(java.util.stream.Collectors.toList());
        }

        /**
         * Check if any error has the specified code.
         */
        public boolean hasErrorCode(String code) {
            return errors.stream()
                .filter(e -> e instanceof ValidationError)
                .map(e -> (ValidationError) e)
                .anyMatch(e -> code.equals(e.getCode()));
        }

        private static String formatErrors(List<?> errors) {
            return errors.stream()
                .map(Object::toString)
                .collect(java.util.stream.Collectors.joining(", "));
        }
    }

    /**
     * Cached version of normalize_currency transform using key-based Flink state.
     * Cache key composed from: currency
     */
    public Map<String, Object> transformWithCache(Map<String, Object> input) throws Exception {
        // Build cache key from specified fields
        String cacheKey = buildNormalizeCurrencyCacheKey(input);

        // Try state lookup by key
        Object cached = normalizeCurrencyCacheMap.get(cacheKey);
        if (cached != null) {
            return (Map<String, Object>) cached;
        }

        // Execute transform and cache result by key
        Map<String, Object> result = transform(input);
        normalizeCurrencyCacheMap.put(cacheKey, result);

        return result;
    }

    /**
     * Invalidate cache entry for the given input's key.
     */
    public void invalidateCache(Map<String, Object> input) throws Exception {
        String cacheKey = buildNormalizeCurrencyCacheKey(input);
        normalizeCurrencyCacheMap.remove(cacheKey);
    }

    /**
     * Clear all cached entries.
     */
    public void clearCache() throws Exception {
        normalizeCurrencyCacheMap.clear();
    }

    /**
     * Error handler for normalize_currency
     */
    private Object handleError(Exception e, Object input) {
        LOG.error("Transform error: {}", e.getMessage());
        throw new TransformRejectedException(e);
    }
    /**
     * Exception thrown when a record should be rejected.
     */
    public static class TransformRejectedException extends RuntimeException {
        public TransformRejectedException(Throwable cause) {
            super("Record rejected during transform", cause);
        }
    }

    /**
     * General transform exception.
     */
    public static class TransformException extends RuntimeException {
        public TransformException(String message, Throwable cause) {
            super(message, cause);
        }
    }

}