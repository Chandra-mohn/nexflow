/**
 * NormalizeCurrencyFunction
 *
 * MapFunction for normalize_currency
 *
 * AUTO-GENERATED by Nexflow Code Generator
 * DO NOT EDIT - Changes will be overwritten
 *
 * Generator: TransformGenerator
 */

package nexflow.flink.transform;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

import org.apache.flink.api.common.functions.RichMapFunction;
import org.apache.flink.api.common.state.StateTtlConfig;
import org.apache.flink.api.common.state.ValueState;
import org.apache.flink.api.common.state.ValueStateDescriptor;
import org.apache.flink.api.common.time.Time;
import org.apache.flink.configuration.Configuration;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class NormalizeCurrencyFunction extends RichMapFunction<Map<String, Object>, Map<String, Object>> {

    private static final Logger LOG = LoggerFactory.getLogger(NormalizeCurrencyFunction.class);
    // Pure function - no side effects

    // Flink State-based Cache Configuration
    private transient ValueState<Object> normalizeCurrencyCacheState;

    @Override
    public void open(Configuration parameters) throws Exception {
        super.open(parameters);

        // Configure state TTL for cache expiration
        StateTtlConfig ttlConfig = StateTtlConfig
            .newBuilder(Time.milliseconds(3600000L))
            .setUpdateType(StateTtlConfig.UpdateType.OnCreateAndWrite)
            .setStateVisibility(StateTtlConfig.StateVisibility.NeverReturnExpired)
            .build();

        ValueStateDescriptor<Object> normalizeCurrencyCacheStateDesc =
            new ValueStateDescriptor<>("normalize_currency_cache", Object.class);
        normalizeCurrencyCacheStateDesc.enableTimeToLive(ttlConfig);
        normalizeCurrencyCacheState = getRuntimeContext().getState(normalizeCurrencyCacheStateDesc);
    }

    /**
     * Build cache key from currency
     */
    private String buildNormalizeCurrencyCacheKey(Map<String, Object> input) {
        StringBuilder keyBuilder = new StringBuilder();
        keyBuilder.append(String.valueOf(input.get("currency")));
        return keyBuilder.toString();
    }


    @Override
    public Map<String, Object> map(Map<String, Object> input) throws Exception {
        return transformWithCache(input);
    }

    /**
     * Transform: normalize_currency
     * Normalizes currency amounts to USD
     */
    public Map<String, Object> transform(Map<String, Object> input) throws Exception {
        validateInput(input);

        Map<String, Object> result = new HashMap<>();

        // Apply transformation logic
        result.put("rate", getExchangeRate(input.get("currency"), "USD"));
        result.put("normalized_amount", (((Number)input.get("amount")).doubleValue() * ((Number)result.get("rate")).doubleValue()));

        validateOutput(result);

        return result;
    }

    /**
     * Validates input data before transformation.
     */
    private void validateInput(Map<String, Object> input) throws ValidationException {
        List<String> errors = new ArrayList<>();

        // Validation: Amount must be positive
        if (!((((Number)input.get("amount")).doubleValue() > 0d))) {
            errors.add("Amount must be positive");
        }
        // Validation: Unsupported currency
        if (!(Arrays.asList("USD", "EUR", "GBP", "JPY", "CAD").contains(input.get("currency")))) {
            errors.add("Unsupported currency");
        }

        if (!errors.isEmpty()) {
            throw new ValidationException("Input validation failed", errors);
        }
    }

    /**
     * Validates output data after transformation.
     */
    private void validateOutput(Map<String, Object> output) throws ValidationException {
        List<String> errors = new ArrayList<>();

        // Validation: Normalized amount must be positive
        if (!((((Number)output.get("normalized_amount")).doubleValue() > 0d))) {
            errors.add("Normalized amount must be positive");
        }

        if (!errors.isEmpty()) {
            throw new ValidationException("Output validation failed", errors);
        }
    }

    /**
     * Exception thrown when validation fails.
     */
    public static class ValidationException extends Exception {
        private final List<String> errors;

        public ValidationException(String message, List<String> errors) {
            super(message + ": " + String.join(", ", errors));
            this.errors = errors;
        }

        public List<String> getErrors() {
            return errors;
        }
    }

    /**
     * Cached version of normalize_currency transform using Flink state.
     */
    public Map<String, Object> transformWithCache(Map<String, Object> input) throws Exception {
        // Try state lookup
        Object cached = normalizeCurrencyCacheState.value();
        if (cached != null) {
            return (Map<String, Object>) cached;
        }

        // Execute transform and cache result in state
        Map<String, Object> result = transform(input);
        normalizeCurrencyCacheState.update(result);

        return result;
    }

    /**
     * Error handler for normalize_currency
     */
    private Object handleError(Exception e, Object input) {
        LOG.error("Transform error: {}", e.getMessage());
        throw new TransformRejectedException(e);
    }
    /**
     * Exception thrown when a record should be rejected.
     */
    public static class TransformRejectedException extends RuntimeException {
        public TransformRejectedException(Throwable cause) {
            super("Record rejected during transform", cause);
        }
    }

    /**
     * General transform exception.
     */
    public static class TransformException extends RuntimeException {
        public TransformException(String message, Throwable cause) {
            super(message, cause);
        }
    }

}