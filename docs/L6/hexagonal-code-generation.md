# Hexagonal Architecture for Generated Code

> **Layer**: L6 - Compilation Pipeline
> **Status**: Design Discussion (Decision Pending)
> **Version**: 0.1.0
> **Last Updated**: 2025-11-28

---

## 1. Overview

This document explores applying **Hexagonal Architecture (Ports & Adapters)** to the code generated by the L6 Compilation Pipeline. The goal is to produce runtime code that separates business logic from infrastructure concerns.

### 1.1 Key Insight

Hexagonal architecture applies to **generated output**, not the Nexflow tooling itself:

```
┌─────────────────────────────────────────────────────────────────┐
│  INPUT                           OUTPUT                         │
│  .proc + .schema + .xform        Generated Application          │
│  + .rules + .infra        ──►    with Hexagonal Structure       │
│                                                                 │
│         L6 Compiler generates hexagonal code                    │
└─────────────────────────────────────────────────────────────────┘
```

### 1.2 Decision Status

| Aspect | Status |
|--------|--------|
| Adopt Hexagonal for Generated Code | **Pending Decision** |
| OOP vs Functional Implementation | **Pending Decision** |
| Target Language(s) | **Pending Decision** |

---

## 2. Hexagonal Principles Applied to Nexflow

### 2.1 Core Concept

```
┌─────────────────────────────────────────────────────────────────┐
│                     HEXAGONAL STRUCTURE                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   DOMAIN CORE (Pure Business Logic)                             │
│   ├── No framework imports (no Kafka, Flink, MongoDB)          │
│   ├── No I/O operations                                        │
│   └── Depends only on PORTS (abstractions)                     │
│                                                                 │
│   PORTS (Contracts/Interfaces)                                  │
│   ├── Define HOW domain interacts with outside world           │
│   └── Abstract away infrastructure details                     │
│                                                                 │
│   ADAPTERS (Concrete Implementations)                           │
│   ├── Implement ports for specific infrastructure              │
│   └── Generated from L5 .infra bindings                        │
│                                                                 │
│   Dependency Rule: Adapters → Ports → Domain Core              │
│   (Dependencies always point INWARD)                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 Mapping Nexflow Layers to Hexagonal

| Nexflow Layer | Hexagonal Role | Generated Output |
|----------------|----------------|------------------|
| L1 Process Orchestration | Domain Core | Pure orchestration logic |
| L2 Schema Registry | Domain Core | Data structures (DTOs/Records) |
| L3 Transform Catalog | Domain Core | Pure transformation functions |
| L4 Business Rules | Domain Core | Pure rule evaluation logic |
| L5 Infrastructure Binding | Adapter Definitions | Concrete adapters |
| L6 Compilation Pipeline | Generator | Produces hexagonal code |

---

## 3. Generated Output Structure

### 3.1 Directory Layout

```
generated/
├── domain/                    # CORE (Pure Business Logic)
│   ├── processes/
│   │   └── AuthorizationEnrichment.{java|scala|py}
│   ├── schemas/
│   │   └── AuthEvent.{java|scala|py}
│   ├── transforms/
│   │   └── NormalizeAmount.{java|scala|py}
│   └── rules/
│       └── FraudDetection.{java|scala|py}
│
├── ports/                     # INTERFACES (Contracts)
│   ├── StreamSource.{java|scala|py}
│   ├── StreamSink.{java|scala|py}
│   ├── LookupStore.{java|scala|py}
│   ├── StateStore.{java|scala|py}
│   └── SecretProvider.{java|scala|py}
│
├── adapters/                  # IMPLEMENTATIONS (from .infra)
│   ├── kafka/
│   │   ├── KafkaAuthEventsSource.{java|scala|py}
│   │   └── KafkaEnrichedAuthsSink.{java|scala|py}
│   ├── mongo/
│   │   └── MongoCustomerLookup.{java|scala|py}
│   ├── redis/
│   │   └── RedisCurrencyRateLookup.{java|scala|py}
│   └── vault/
│       └── VaultSecretProvider.{java|scala|py}
│
└── wiring/                    # COMPOSITION ROOT
    └── ApplicationFactory.{java|scala|py}
```

---

## 4. Implementation Paradigms

### 4.1 Option A: Object-Oriented (OOP)

**Port Definition (Interface):**
```java
// ports/CustomerLookup.java
public interface CustomerLookup {
    Customer findByCardId(String cardId);
    Optional<Customer> findByCardIdIfExists(String cardId);
}
```

**Domain Core (Uses Port):**
```java
// domain/processes/AuthorizationEnrichment.java
public class AuthorizationEnrichment {
    private final CustomerLookup customerLookup;
    private final CurrencyRateLookup rateLookup;

    // Constructor injection
    public AuthorizationEnrichment(
            CustomerLookup customerLookup,
            CurrencyRateLookup rateLookup) {
        this.customerLookup = customerLookup;
        this.rateLookup = rateLookup;
    }

    // Pure business logic - no Kafka, no Mongo, no Flink
    public EnrichedAuth process(AuthEvent event) {
        Customer customer = customerLookup.findByCardId(event.getCardId());
        BigDecimal rate = rateLookup.getRate(event.getCurrency());
        BigDecimal amountUsd = event.getAmount().multiply(rate);

        return EnrichedAuth.builder()
            .transactionId(event.getTransactionId())
            .customer(customer)
            .amountUsd(amountUsd)
            .build();
    }
}
```

**Adapter (Implements Port):**
```java
// adapters/mongo/MongoCustomerLookup.java
public class MongoCustomerLookup implements CustomerLookup {
    private final MongoCollection<Document> collection;

    public MongoCustomerLookup(MongoConfig config) {
        MongoClient client = MongoClients.create(config.getUri());
        this.collection = client
            .getDatabase(config.getDatabase())
            .getCollection(config.getCollection());
    }

    @Override
    public Customer findByCardId(String cardId) {
        Document doc = collection.find(eq("card_id", cardId)).first();
        return mapToCustomer(doc);
    }
}
```

**Wiring:**
```java
// wiring/ApplicationFactory.java
public class ApplicationFactory {
    public static AuthorizationEnrichment create(InfraConfig config) {
        CustomerLookup customerLookup = new MongoCustomerLookup(config.getMongo());
        CurrencyRateLookup rateLookup = new RedisCurrencyRateLookup(config.getRedis());

        return new AuthorizationEnrichment(customerLookup, rateLookup);
    }
}
```

---

### 4.2 Option B: Functional Programming (FP)

**Port Definition (Type Alias):**
```python
# ports/types.py
from typing import Callable, Optional
from decimal import Decimal

# Ports are function signatures
LookupCustomer = Callable[[str], Customer]           # CardId -> Customer
LookupRate = Callable[[str], Decimal]                # CurrencyCode -> Rate
EmitEvent = Callable[[Event], None]                  # Event -> IO ()
GetVelocity = Callable[[str, int], int]              # (CardId, Seconds) -> Count
```

**Domain Core (Pure Functions):**
```python
# domain/processes/authorization.py
from ports.types import LookupCustomer, LookupRate

def enrich_auth(
    event: AuthEvent,
    lookup_customer: LookupCustomer,
    lookup_rate: LookupRate
) -> EnrichedAuth:
    """
    Pure function - dependencies passed as function arguments.
    No imports from kafka, mongo, redis, flink.
    """
    customer = lookup_customer(event.card_id)
    rate = lookup_rate(event.currency)
    amount_usd = event.amount * rate

    return EnrichedAuth(
        transaction_id=event.transaction_id,
        customer=customer,
        amount_usd=amount_usd
    )
```

**Adapter (Returns Function):**
```python
# adapters/mongo.py
from pymongo import MongoClient
from ports.types import LookupCustomer

def mongo_lookup_customer(config: MongoConfig) -> LookupCustomer:
    """
    Adapter factory: returns a function that satisfies the LookupCustomer port.
    """
    client = MongoClient(config.uri)
    collection = client[config.database][config.collection]

    def lookup(card_id: str) -> Customer:
        doc = collection.find_one({"card_id": card_id})
        return Customer.from_dict(doc)

    return lookup
```

**Wiring (Function Composition):**
```python
# wiring/factory.py
from domain.processes.authorization import enrich_auth
from adapters.mongo import mongo_lookup_customer
from adapters.redis import redis_lookup_rate
from adapters.kafka import kafka_emit

def create_pipeline(config: InfraConfig):
    """
    Wire adapters to domain via partial application.
    Returns a fully-configured processing function.
    """
    # Create adapter functions
    lookup_customer = mongo_lookup_customer(config.mongo)
    lookup_rate = redis_lookup_rate(config.redis)
    emit = kafka_emit(config.kafka_sink)

    # Compose into pipeline
    def process(event: AuthEvent) -> EnrichedAuth:
        enriched = enrich_auth(event, lookup_customer, lookup_rate)
        emit(enriched)
        return enriched

    return process

# Usage
pipeline = create_pipeline(load_infra("production.infra"))
for event in stream:
    pipeline(event)
```

---

## 5. Comparison Matrix

### 5.1 OOP vs FP Hexagonal

| Aspect | OOP | FP |
|--------|-----|-----|
| **Port Definition** | Interface | Type alias / Function signature |
| **Adapter** | Class implements interface | Function returns function |
| **Dependency Injection** | Constructor injection | Partial application / Closure |
| **Testing** | Mock objects | Pass stub functions |
| **Boilerplate** | More (interfaces + classes) | Less (just functions + types) |
| **Generated File Count** | Higher | Lower |
| **Java Compatibility** | Native | Requires Java 8+ lambdas |
| **Scala/Python Fit** | Good | Excellent |
| **Flink API Fit** | Native (ProcessFunction) | Needs wrapping |
| **Spark API Fit** | Okay | Natural (RDD/Dataset) |

### 5.2 Language Recommendations by Target

| Target Runtime | Recommended Paradigm | Rationale |
|----------------|---------------------|-----------|
| Flink (Java) | OOP | Flink's Java API is class-based |
| Flink (Scala) | FP | Flink Scala API supports FP well |
| Spark (Scala) | FP | Spark is fundamentally functional |
| Spark (Python) | FP | PySpark is functional |
| Kafka Streams | FP | Stream DSL is functional composition |

---

## 6. Benefits Analysis

### 6.1 Advantages of Hexagonal Code Generation

| Benefit | Impact |
|---------|--------|
| **Testability** | Test `domain/` classes with mock ports - no Kafka/Flink/Mongo needed |
| **Portability** | Same business logic works on Flink, Spark, or future runtimes |
| **Team Boundaries** | Clear contracts between platform team (adapters) and domain teams (core) |
| **Debugging** | Bug isolation: business logic bugs in `domain/`, infra bugs in `adapters/` |
| **Compliance** | Audit L4 rules independently of execution environment |
| **Onboarding** | New developers understand structure without learning Flink internals |

### 6.2 Complexity Trade-offs

| Dimension | Without Hexagonal | With Hexagonal |
|-----------|------------------|----------------|
| Initial L6 Development | Simpler | More upfront design |
| Adding New Runtime | Rewrite code gen | Generate new adapters only |
| Unit Testing | Need framework test harness | Plain unit tests with mocks |
| Number of Generated Files | Fewer, larger | More, smaller |
| Performance Tuning | Direct access | May need escape hatches |
| Production Debugging | Grep monolithic class | Trace through layers |

---

## 7. Support Complexity Assessment

### 7.1 What Gets Easier

```
Bug in business logic?     → Look in domain/
Bug in Kafka connection?   → Look in adapters/
Bug in contract mismatch?  → Look in ports/

vs. Monolithic:
Bug anywhere?              → Search 5000-line coupled class
```

### 7.2 What Gets Harder

- **Performance debugging**: Abstraction layer may hide framework-specific tuning knobs
- **More files to navigate**: 200-300 generated files vs 50 monolithic classes
- **Initial learning curve**: Developers must understand ports/adapters pattern

### 7.3 Mitigation Strategies

| Challenge | Mitigation |
|-----------|------------|
| Performance tuning | Generate optional `@DirectAccess` escape hatches |
| File navigation | Clear naming conventions, good IDE tooling |
| Learning curve | Documentation, examples, onboarding guides |

---

## 8. Implementation Recommendation

### 8.1 Pragmatic Approach

If hexagonal is adopted, recommend **progressive implementation**:

| Phase | Scope | Rationale |
|-------|-------|-----------|
| Phase 1 | L4 Rules only | Biggest testability win, clearest boundary |
| Phase 2 | L3 Transforms | Natural pure functions |
| Phase 3 | L1 Orchestration | Most complex, do last |

### 8.2 Hybrid Option

```
┌─────────────────────────────────────────────────────────────────┐
│  HYBRID: Hexagonal Core + Thin Framework Wrapper               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  domain/           Pure hexagonal business logic                │
│  ports/            Abstract interfaces                          │
│  adapters/         Infrastructure implementations               │
│  framework/        Thin Flink/Spark wrappers that delegate     │
│                    to domain - framework-specific code isolated │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 9. Examples

### 9.1 Generated Code: Before vs After

**BEFORE (Tightly Coupled):**
```java
public class AuthorizationEnrichment extends ProcessFunction<AuthEvent, EnrichedAuth> {
    private transient MongoClient mongoClient;  // Infrastructure leak!

    @Override
    public void open(Configuration config) {
        mongoClient = MongoClients.create(getRuntimeContext().getConfig());
    }

    @Override
    public void processElement(AuthEvent event, Context ctx, Collector<EnrichedAuth> out) {
        // Business logic mixed with infrastructure
        Document doc = mongoClient.getDatabase("credit_card")
            .getCollection("customers")
            .find(eq("card_id", event.getCardId()))
            .first();
        Customer customer = mapToCustomer(doc);
        // ... more mixed code
    }
}
```

**AFTER (Hexagonal):**
```java
// domain/AuthorizationEnrichment.java - PURE
public class AuthorizationEnrichment {
    private final CustomerLookup customerLookup;  // Port, not MongoClient!

    public EnrichedAuth process(AuthEvent event) {
        Customer customer = customerLookup.findByCardId(event.getCardId());
        // Pure business logic, no framework imports
        return enrich(event, customer);
    }
}

// framework/FlinkAuthorizationWrapper.java - THIN WRAPPER
public class FlinkAuthorizationWrapper extends ProcessFunction<AuthEvent, EnrichedAuth> {
    private final AuthorizationEnrichment domain;

    @Override
    public void processElement(AuthEvent event, Context ctx, Collector<EnrichedAuth> out) {
        out.collect(domain.process(event));  // Delegate to pure domain
    }
}
```

---

## 10. Open Questions

| Question | Options | Notes |
|----------|---------|-------|
| Adopt hexagonal? | Yes / No / Hybrid | Core architectural decision |
| OOP or FP? | OOP / FP / Both | May depend on target language |
| Primary language? | Java / Scala / Python | Affects idioms and patterns |
| Port granularity? | Fine (`StreamSource`) / Coarse (`InfraContext`) | Trade-off: flexibility vs simplicity |
| Escape hatches? | Yes / No | For performance-critical paths |

---

## 11. Decision Log

| Date | Decision | Rationale |
|------|----------|-----------|
| 2025-11-28 | Document created | Capture hexagonal options for future decision |
| - | - | - |

---

## Document History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 0.1.0 | 2025-11-28 | - | Initial design discussion document |
